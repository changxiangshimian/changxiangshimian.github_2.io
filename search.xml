<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Lucene&Solr_day01]]></title>
      <url>%2F2017%2F04%2F11%2FLucene-Solr-day01%2F</url>
      <content type="text"><![CDATA[Lucene实现全文检索的流程 数据分类 结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等 非结构化数据: 指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件 Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面索引和搜索流程图 创建文档对象 获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。 我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容） 注意:每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同） 文档分析 根据规定的规则,把文档的文件名,路径,文本内容,文本大小等信息筛选出来 123456/*将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。例如：文件名中包含apache和文件内容中包含的apache是不同的term。 */ 查询索引 查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件） 下载地址:http://lucene.apache.org/ Field域的属性 创建索引库代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Testpublic void test1() throws IOException&#123; //创建一个解析器 StandardAnalyzer analyzer = new StandardAnalyzer(); //创建一个IndexWriterConfig解析对象 //第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST,analyzer); //指定索引库存放的路径 FSDirectory directory = FSDirectory.open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\test")); //创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory,config); //初始文件的位置 File file = new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\first"); for (File f : file.listFiles()) &#123; //获取文件名 String fileName = f.getName(); //获取文件的大小 Long fileSize = FileUtils.sizeOf(f); //获取文件的内容 String fileContent = FileUtils.readFileToString(f); //获取文件的路径 String filePath = f.getPath(); //文件名域 TextField fileNameField = new TextField("name",fileName,Store.YES); //配置文件大小域 LongField fileSizeField = new LongField("size",fileSize,Store.YES); //配置文件内容域 TextField fileContentField = new TextField("content",fileContent,Store.YES); //配置文件路径域 StoredField filePathField = new StoredField("path",filePath); //创建一个Document对象 Document document = new Document(); //把文件的各个域放在Document中 document.add(fileNameField); document.add(fileSizeField); document.add(fileContentField); document.add(filePathField); //把Document添加到IndexWriter里面去 indexWriter.addDocument(document); &#125; //执行完成后要记得关闭IndexWriter indexWriter.close();&#125; 生成的数据为 查询索引库代码实现 创建一个Directory对象，也就是索引库存放的位置 创建一个indexReader对象，需要指定Directory对象 创建一个indexsearcher对象，需要指定IndexReader对象 创建一个TermQuery对象，指定查询的域和查询的关键词 执行查询 返回查询结果。遍历查询结果并输出 关闭IndexReader对象 1234567891011121314151617181920212223@Testpublic void searchIndex() throws IOException&#123; //指定索引库存放的路径 FSDirectory directory = FSDirectory.open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\test")); //创建 indexsearcher对象 DirectoryReader indexReader = DirectoryReader.open(directory); //创建IndexSearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建查询 查看有没有文件名带有的 Query query = new TermQuery(new Term("name","txt")); //执行查询 只返回两条结果 TopDocs topDocs = indexSearcher.search(query, 3); System.out.println("共查询出了"+topDocs.totalHits+"条记录"); //遍历 for (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; //scoreDoc.doc返回的就是Document的id Document document = indexSearcher.doc(scoreDoc.doc); System.out.println(document.get("name")); System.out.println(document.get("path")); System.out.println(document.get("size")); &#125; indexReader.close();&#125; 查询的结果为 中文分析器IKAnalyzer 代码 1234567891011121314151617181920212223242526272829@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); // 初始文件的位置 // 创建一个Document对象 Document document = new Document(); // 把文件的各个域放在Document中 document.add(new TextField("filename", "新添加的文档", Store.YES)); document.add(new TextField("content", "新添加的文档的内容", Store.NO)); document.add(new TextField("content", "新添加的文档的内容第二个content", Store.YES)); document.add(new TextField("content1", "新添加的文档的内容要能看到", Store.YES)); // 把Document添加到IndexWriter里面去 indexWriter.addDocument(document); // 执行完成后要记得关闭IndexWriter indexWriter.close();&#125; 删除全部代码 代码示例慎用 12345678910111213141516171819@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //删除全部索引 indexWriter.deleteAll(); //关闭indexwriter indexWriter.close();&#125; 查询条件删除 代码示例 1234567891011121314151617181920@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个查询条件 Query query = new TermQuery(new Term("filename", "apache")); //根据查询条件删除 indexWriter.deleteDocuments(query); //关闭indexwriter indexWriter.close();&#125; 索引库的修改 原理就是先删除后添加 1234567891011121314151617181920212223@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField("filename", "要更新的文档", Store.YES)); document.add(new TextField("content", "2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。", Store.YES)); indexWriter.updateDocument(new Term("content", "java"), document); //关闭indexWriter indexWriter.close();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh的Dao,Service,action]]></title>
      <url>%2F2017%2F04%2F10%2Fssh%E7%9A%84Dao-Service-action%2F</url>
      <content type="text"><![CDATA[创建实体类和映射 PowerDesigner 创建表与表之间的关系 生成pdm文件 让myeclipse链接上数据库生成实体类和对应的映射文件建立Dao,Service,action之间的关系 Dao 先创建一个BaseDao的接口里面提供一些通用的方法 1234567891011121314151617181920212223242526public interface BaseDao&lt;T&gt; &#123; public void save(T entity); public void delete(T entity); public void update(T entity); public T findById(Serializable id); public List&lt;T&gt; findAll(); /** * 根据条件查询对象查询 */ public List&lt;T&gt; findByCriteria(DetachedCriteria criteria); /** * 根据命名查询语句查询 */ public List&lt;T&gt; findByNamedQuery(String queryName,Object...args); /** * 执行增删改操作的命名语句 */ public void executeNamedQuery(String queryName,Object ...args); public Map&lt;String,Object&gt; getPage(PageBean pageBean);&#125; * 然后创建Base的实现类,实现BaseDao里面的一些抽象方法 * 首先得获得Service里面传过来的类型的对象:`如下` 1234567891011121314// 定义一个属性，表示实体的类型private Class&lt;T&gt; domainClass;/** * 在构造方法中动态获得实体的类型 */public BaseDaoImpl() &#123; // 获得父类类型 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass(); // 获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); // 获得实体类型 domainClass = (Class&lt;T&gt;) actualTypeArguments[0];&#125; * 注入会话工厂对象 12345@Resourcepublic void setSF(SessionFactory sessionFactory)&#123; //调用父类的方法注入会话工厂对象 super.setSessionFactory(sessionFactory);&#125; * 对BaseDao接口里面的方法进行实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void save(T entity) &#123; this.getHibernateTemplate().save(entity); &#125;@Overridepublic void delete(T entity) &#123; this.getHibernateTemplate().delete(entity); &#125;@Overridepublic void update(T entity) &#123; this.getHibernateTemplate().update(entity); &#125;@Overridepublic T findById(Serializable id) &#123; return this.getHibernateTemplate().get(domainClass, id);&#125;@Overridepublic List&lt;T&gt; findAll() &#123; String hql = "From "+domainClass.getSimpleName(); // TODO Auto-generated method stub return this.getHibernateTemplate().find(hql);&#125;@Overridepublic List&lt;T&gt; findByCriteria(DetachedCriteria criteria) &#123; // TODO Auto-generated method stub return this.getHibernateTemplate().findByCriteria(criteria);&#125;@Overridepublic List&lt;T&gt; findByNamedQuery(String queryName, Object... args) &#123; // TODO Auto-generated method stub return this.getHibernateTemplate().findByNamedQuery(queryName, args);&#125;@Overridepublic void executeNamedQuery(String queryName, Object... args) &#123; // TODO Auto-generated method stub Session session = (Session) this.getSession(); Query query = session.getNamedQuery(queryName); if (args != null &amp;&amp; args.length &gt; 0) &#123; int i = 0; for (Object arg : args) &#123; query.setParameter(i++, arg); &#125; &#125; query.executeUpdate();&#125;@Overridepublic Map&lt;String,Object&gt; getPage(PageBean pageBean) &#123; // TODO Auto-generated method stub pageBean.setTotal(findAll().size()); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("total", pageBean.getTotal()); int firstResult = (pageBean.getCurrentPage()-1)*pageBean.getPageSize(); int maxResults = pageBean.getPageSize(); List&lt;Object&gt; list = this.getHibernateTemplate().findByCriteria(pageBean.getDetachedCriteria(), firstResult, maxResults); map.put("rows", list);/* Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println("key:"+string+" value:"+map.get(string)); &#125;*/ return map;&#125; * `在书写实体类Dao的接口时,这个接口要继承BaseDao接口` * `在书写实体类Dao接口的实现类的时候,要继承BaseDao接口的实现类.` * 注意类上面要写 `@Repository` Service 提供service层的实现类和接口,并在实现类里面注入Dao层的实体对象接口@Resource 在实现类上面要加上注解@Service @Transactional Action 创建BaseAction 继承ActionSupport类 实现 ModelDriven接口 public class BaseAction&lt;T&gt; extends ActionSupport implements ModelDriven&lt;T&gt; { } 获得传过来的模型对象 123456789101112131415161718192021222324252627//声明模型对象protected T model;public T getModel() &#123; return model;&#125; //在构造方法中动态获得实体的类型，并通过反射实例化模型对象public BaseAction() &#123; //获得父类（BaseAction&lt;T&gt;）类型 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass(); //获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); //实体类型 Class&lt;T&gt; domainClass = (Class&lt;T&gt;) actualTypeArguments[0]; try &#123; //创建PageBean的离线查询对象 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(domainClass); pageBean.setDetachedCriteria(detachedCriteria); //创建模型对象并赋给model model = domainClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; * 在里面填写`@Resource`标签注入XxxService * 注意权限访问范围是&apos;protected&apos; * 其余代码 123456789protected PageBean pageBean = new PageBean();public void setCurrentPage(int currentPage)&#123; pageBean.setCurrentPage(currentPage);&#125;public void setPageSize(int pageSize)&#123; pageBean.setPageSize(pageSize);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[activiti流程管理]]></title>
      <url>%2F2017%2F04%2F10%2Factiviti%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[activiti的搭建.完成自动创表 创建一个xml的配置文件 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 配置一个流程引擎对象 --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcDriver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///activiti_day01"&gt;&lt;/property&gt; &lt;property name="jdbcUsername" value="root"&gt;&lt;/property&gt; &lt;property name="jdbcPassword" value="123"&gt;&lt;/property&gt; &lt;property name="databaseSchemaUpdate" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个流程引擎工厂bean，用于创建流程引擎对象 --&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建一个测试类运行测试类,在数据库里面表就创建好了 1234567891011121314package com.yyt.activiti;import org.activiti.engine.ProcessEngineConfiguration;import org.junit.Test;public class Demo &#123; @Test public void test1() &#123; ProcessEngineConfiguration conf = ProcessEngineConfiguration .createProcessEngineConfigurationFromResource("activiti-context.xml", "processEngineConfiguration"); conf.buildProcessEngine(); &#125;&#125; 或者在xml配置文件内容不变的前提下,测试类还可以这样写 前提: 配置文件的名称必须为activiti-context.xml或者为activiti.cfg.xml,xml配置文件中必须配置流程引擎配置对象，id必须为processEngineConfiguration，必须配置流程引擎工厂bean，id必须为processEngine 1234@Testpublic void test2()&#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();&#125; 了解activiti框架提供的23张表Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 ACTRE*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 ACTRU*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 ACTID*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACTHI*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACTGE*: 通用数据， 用于不同场景下 部署流程定义 定义一个全局变量的ProcessEngine因为这个属性很常用 private ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); 部署流程定义就是将设计的流程规则保存到数据库中 代码 12345678910111213141516171819@Testpublic void test3()&#123; //配置流程的规则把myActiviti.bpmn导入进去 //配置流程的图解,导入myActiviti.png /* 先获取流程定义和流程静态资源 （图片，规则，等等）对象,然后再在关于流程规则和定义中的表中,创建deployment表的对象,这与数据库中的deployment表对应 */ DeploymentBuilder deploymentBuilder = processEngine.getRepositoryService().createDeployment(); //在数据库中插入图片 deploymentBuilder.addClasspathResource("myActiviti.png"); //在数据库中插入规则 deploymentBuilder.addClasspathResource("myActiviti.bpmn"); //提交数据,把数据提交到数据库中 Deployment deployment = deploymentBuilder.deploy(); //打印deployment表中的id值 System.out.println(deployment.getId()); &#125; 查询流程定义 代码实现 12345678910111213141516// 查询流程的定义@Testpublic void test4() &#123; // 获得流程查询对象 ProcessDefinitionQuery query = processEngine.getRepositoryService().createProcessDefinitionQuery(); //根据数据库中的key过滤 query.processDefinitionKey("myProcess"); //根据Version 版本 进行降序排序 query.orderByProcessDefinitionVersion().desc(); //把query转成list集合,泛型为ProcessDefinition List&lt;ProcessDefinition&gt; list = query.list(); for (ProcessDefinition processDefinition : list) &#123; System.out.println(processDefinition.getVersion()); &#125;&#125; 流程实例根据某个流程定义(流程的规则)的一次具体执行过程，就是一个流程实例(按照流程规则执行的一次事件)。流程定义和流程实例是一对多的关系 启动一个流程实例 12345678910@Testpublic void test5()&#123; //写出在数据库名为procdef的表中的id String procdefId = "myProcess:1:4"; //获得运行时的Service,并开始处理流程实例,根据procdef表中的id //一般根据KEY生成一个实例,根据KEY生成的话,默认是按照最新版本的流程规则创造流程实例 ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceById(procdefId); //打印出流程实例对象的id 对应数据表中的execution中表的id ps:execution表中ACT_ID_ 表示的是该任务节点的处理人 System.out.println(processInstance.getId());&#125; 在act_ru_task表里会保存当前任务的信息，包括流程实例的IdPROC_INST_ID_，任务名称NAME_，任务的办理人ASSIGNEE_ 查询任务1234567891011@Testpublic void test6()&#123; //通过获取task的service,来创建task的查询对象 ps task:正在执行任务的表 TaskQuery query = processEngine.getTaskService().createTaskQuery(); //向查询对象中添加过滤条件(通过Assignee:本次任务第一阶段的处理人),并转换为list集合 List&lt;Task&gt; list = query.taskAssignee("张三").list(); for (Task task : list) &#123; //打印task表中满足过滤条件的name信息 System.out.println(task.getName()); &#125;&#125; 办理任务把任务推往下一层12345@Testpublic void test7()&#123; //里面填写task表中的ID,就把当前任务id的流程推向了下一层去审批 processEngine.getTaskService().complete("504");&#125; 流程变量 就比如你请假,向领导报告请假理由和请假天数,而这些参数就是流程变量,这些变量在整个流程中都是可以被随时调用的 流程变量保存在act_ru_variable表中 Name字段保存的是变量的key,Text字段保存的是变量的value 代码一:在创建实例的时候向方法里面添加参数(有参构造) 12345678@Testpublic void test8()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "割包皮"); map.put("请假天数","15"); //ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceByKey("myProcess", map); ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceById("myProcess:2:104", map);&#125; 代码二:办理任务时设置 1234567@Testpublic void test9()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "世界这麽大我想去看看"); map.put("请假天数","无限期"); processEngine.getTaskService().complete("404",map);&#125; ps:在流程变量设置好后,向下一级提交的时候,该流程变量也可以改变 就比如你向项目经理请假,想请2天假原因是XXX过生日,但是项目经理向部门经理反映的是你想请20天的假原因是世界这麽大我想去看看 代码: 12345678@Testpublic void test10()&#123; //里面填写task表中的ID,就把当前任务id的流程推向了下一层去审批 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "他不想干了"); map.put("请假天数","干脆把他开除了吧!"); processEngine.getTaskService().complete("1304",map);&#125; 代码三:在RuntimeService方法里面设置 12345678@Testpublic void test11()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "不想上班了"); map.put("请假天数","辞职"); //设置多个流程变量用这个,设置单个的话用setVariables("流程id",流程变量标题,流程变量的内容) processEngine.getRuntimeService().setVariables("1001", map);&#125; 代码四:TaskService的方法设置流程变量 1234567@Testpublic void test12() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "不吻"); map.put("请假天数", "滚"); processEngine.getTaskService().setVariables("1106", map);&#125; 获取流程变量 代码一根据RuntimeService方法获取 12345678910@Testpublic void test13() &#123; Map&lt;String, Object&gt; map = processEngine.getRuntimeService().getVariables("1101"); Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println(string + "--" + map.get(string)); &#125;&#125; 代码二根据TaskService方法获取 123456789@Testpublic void test14() &#123; Map&lt;String, Object&gt; map = processEngine.getTaskService().getVariables("1106"); Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println(string + "--" + map.get(string)); &#125;&#125; 候选组 组任务 先启动一个流程实例 创建一个组 12345678//创建财务人员组@Testpublic void test3()&#123; Group group = new GroupEntity(); group.setId("财务人员组"); group.setName("财务人员组猪猪"); processEngine.getIdentityService().saveGroup(group);&#125; 再创建一个用户 123456789//创建一个用户@Testpublic void test4()&#123; Group group = new GroupEntity(); User user = new UserEntity(); user.setId("002"); user.setFirstName("小黄"); processEngine.getIdentityService().saveUser(user);&#125; 将用户加入组中 1234567//将用户加入组中@Testpublic void test5()&#123; String userid = "002"; String group = "主管人员组"; processEngine.getIdentityService().createMembership(userid, group);&#125; 然后在流程处理到了组哪里的时候,就把组里面的单个人提取出来,为你办理任务123456@Testpublic void test8()&#123; String taskid = "2805"; String userid = "002"; processEngine.getTaskService().claim(taskid, userid);&#125; 排他网关 结构图 ${qjtj&lt;50} |------&gt;{部门经理}----- | | | | 开始---&gt;{自己}----&gt; X------&gt;{项目经理}-----|-----&gt;{老板}---&gt;结束 | | | | |------&gt;{区域经理}----- ${qjtj&lt;250} 在导入流程规则和图片,并开始处理流程实例后执行下面的代码 执行流程 123456789//执行流程@Testpublic void test3()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String, Object&gt;(); //map集合里面,第一个是条件的名称,给该条件的值 map.put("qjtj", 25); //把条件与流程的id一并提交 processEngine.getTaskService().complete("3204", map);&#125; 查询执行上一个带条件的流程后,现在改流程的name字段,结果应该为 “部门经理” 123456789@Testpublic void test4()&#123; TaskQuery query = processEngine.getTaskService().createTaskQuery(); query.taskId("3304"); List&lt;Task&gt; list = query.list(); for (Task task : list) &#123; System.out.println(task.getName()); &#125;&#125; 并行网关当工作流程运行到并行网关时，会同时开启多条运行的流程实例，多条流程实例可以同时进行，而且，只有所有并行网关的分支流程实例全部执行完毕，流程汇聚，当前任务完成。 分支（fork）:通过了并行网关后，流程实例被分成了若干个子流程 汇聚（join）:子流程执行完毕，最后会集中到主流程上，只要有任意一个子流程没有执行完毕，那么就不会汇聚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro权限管理]]></title>
      <url>%2F2017%2F04%2F10%2FShiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[shiro的配置过程 在web.xml中配置一个过滤器代理对象 123456789&lt;!-- 加入spring框架提供的过滤器代理对象 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在spring配置文件中配置一个名称为shiroFilter的bean,并注入安全管理器 123456789101112131415161718192021222324252627282930313233&lt;!-- 配置安全管理器 --&gt;&lt;bean name="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="bosRealm"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="bosRealm" class="com.yyt.bos.shiro.BOSRealm"&gt;&lt;/bean&gt;&lt;!-- 配置shiro的bean --&gt;&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- 注入安全管理器对象 --&gt; &lt;property name="securityManager" ref="securityManager"&gt;&lt;/property&gt; &lt;!-- 成功的界面 --&gt; &lt;property name="successUrl" value="/index.jsp"&gt;&lt;/property&gt; &lt;!-- 权限不足提示页面 --&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"&gt;&lt;/property&gt; &lt;!-- 登录页面的Url --&gt; &lt;property name="loginUrl" value="/login.jsp"&gt;&lt;/property&gt; &lt;!-- 基于url拦截,使用过滤器进行拦截 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;!-- anon:权限拦截白名单 --&gt; &lt;value&gt; /css/** = anon /images/** = anon /js/** = anon /login.jsp = anon /validatecode.jsp* = anon /userAction_login.action = anon /page_base_staff.action = perms["staff"] /** = authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; bean的名字为bosRealm所在类的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.yyt.bos.shiro;import java.util.List;import javax.annotation.Resource;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import com.yyt.bos.dao.FunctionDao;import com.yyt.bos.dao.UserDao;import com.yyt.bos.entity.Function;import com.yyt.bos.entity.User;public class BOSRealm extends AuthorizingRealm &#123; @Resource private UserDao userDao; @Resource private FunctionDao functionDao; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection paramPrincipalCollection) &#123; // TODO Auto-generated method stub SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); /*info.addStringPermission("staff"); info.addStringPermission("staff-delete");*/ User user = (User) paramPrincipalCollection.getPrimaryPrincipal(); if("李四".equals(user.getUsername()))&#123; List&lt;Function&gt; list = functionDao.findAll(); info.addStringPermission("staff-delete"); info.addStringPermission("staff-add"); for (Function function : list) &#123; System.out.println(function.getName()); info.addStringPermission(function.getCode()); &#125; &#125;else&#123; String id = user.getId(); List&lt;Function&gt; list = functionDao.findFunctionByUsername(id); for (Function function : list) &#123; System.out.println(function.getName()); info.addStringPermission(function.getCode()); &#125; &#125; return info; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; UsernamePasswordToken mytoken = (UsernamePasswordToken) token; String username = mytoken.getUsername(); char[] password = mytoken.getPassword(); User user = userDao.findUserByUsername(username); if(user == null)&#123; return null; &#125; //如果从数据库里面返回的user部位null的话,就说明签名通过了. //三个参数分别为:签名对象;从数据库中查到的密码;reaml的类名 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this.getClass().getName()); return info; &#125;&#125; 修改用户Action里面的登录方法 1234567891011121314151617181920212223public String login()&#123; Subject subject = SecurityUtils.getSubject(); String username = model.getUsername(); String password = model.getPassword(); password = MD5Utils.md5(password); try&#123; AuthenticationToken token = new UsernamePasswordToken(username,password); subject.login(token); User user = (User) subject.getPrincipal(); ServletActionContext.getRequest().getSession().setAttribute("user", user); &#125;catch (UnknownAccountException e) &#123; e.printStackTrace(); this.addActionError("用户名不存在"); return "login"; // TODO: handle exception &#125;catch (IncorrectCredentialsException e)&#123; e.printStackTrace(); this.addActionError("密码错误"); return "login"; &#125; return "home";&#125; 注解方式权限控制 在spring的配置文件中写自动代理和切面 1234567&lt;!-- 自动代理 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt; &lt;property name="proxyTargetClass" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 切面 --&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt;&lt;/bean&gt; 在Action作废的方法上面写注解 12@RequiresPermissions("staff-delete")public String deleteStaff()&#123;...&#125; 修改BaseAction的构造方法虚线中间的为要修改的内容 1234567891011121314151617181920212223242526272829303132//在构造方法中动态获得实体的类型，并通过反射实例化模型对象public BaseAction() &#123;--------------------------------------------------------------------------------------------------- // 获得父类（BaseAction&lt;T&gt;）类型 ParameterizedType genericSuperclass = null; Type genericSuperclass2 = this.getClass().getGenericSuperclass(); if(genericSuperclass2 instanceof ParameterizedType)&#123; genericSuperclass = (ParameterizedType) genericSuperclass2; &#125;else&#123; genericSuperclass = (ParameterizedType) this.getClass().getSuperclass().getGenericSuperclass(); &#125;--------------------------------------------------------------------------------------------------- //获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); //实体类型 Class&lt;T&gt; domainClass = (Class&lt;T&gt;) actualTypeArguments[0]; try &#123; //创建PageBean的离线查询对象 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(domainClass); pageBean.setDetachedCriteria(detachedCriteria); //创建模型对象并赋给model model = domainClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 在jsp页面上根据不同登录用户隐藏按钮 123456789/* 如果登录的用户有此权限则按钮不隐藏,没有此权限则 隐藏按钮*/&lt;shiro:hasPermission name="staff-add"&gt;, &#123; id : 'button-add', text : '增加', iconCls : 'icon-add', handler : doAdd&#125;&lt;/shiro:hasPermission&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>%2F2017%2F04%2F10%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[easyui初级使用]]></title>
      <url>%2F2017%2F04%2F10%2Feasyui%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[什么是easyui jquery easyui不需要写复杂的css和html代码，就可以实现一些页面效果 使用jquery easyui和后台进行交互 通过后台（action）返回json数据到页面 底层使用jquery ajax+json数据 应用场景 使用jquery easyui一般用在后台管理系统基本案例DataGrid(数据表格) DataGrid属性1234567891011121314151617&lt;table class="easyui-datagrid"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th data-options="field:'code'"&gt;编码&lt;/th&gt; &lt;th data-options="field:'name'"&gt;名称&lt;/th&gt; &lt;th data-options="field:'price'"&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;001&lt;/td&gt;&lt;td&gt;名称1&lt;/td&gt;&lt;td&gt;2323&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;002&lt;/td&gt;&lt;td&gt;名称2&lt;/td&gt;&lt;td&gt;4612&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; class=”easyui-datagrid”表示引入easy的表格样式 field :列字段的名称 pagination :是否显示分页条工具 rownumbers :是否显示数据表格的行号 pagePosition :定义分页工具栏的位置,可选值有’top’,’bottom’,’both’ loader 定义如何从远程服务器加载数据。返回false可以放弃本次请求动作。该函数接受以下参数： param：参数对象传递给远程服务器。 success(data)：当检索数据成功的时候会调用该回调函数 error()：当检索数据失败的时候会调用该回调函数 loadFilter 返回过滤数据显示。该函数带一个参数’data’用来指向源数据（即：获取的数据源，比如Json对象）。您可以改变源数据的标准数据格式。这个函数必须返回包含’total’和’rows’属性的标准数据对象。 代码示例 12345678910// 从Web Service（asp.net、java、php等）输出的JSON对象中移除'd'对象$('#dg').datagrid(&#123; loadFilter: function(data)&#123; if (data.d)&#123; return data.d; &#125; else &#123; return data; &#125; &#125;&#125;); 列属性12345678910columns:[[ &#123;field:'itemid',title:'Item ID',rowspan:2,width:80,sortable:true&#125;, &#123;field:'productid',title:'Product ID',rowspan:2,width:80,sortable:true&#125;, &#123;title:'Item Details',colspan:4&#125; ],[ &#123;field:'listprice',title:'List Price',width:80,align:'right',sortable:true&#125;, &#123;field:'unitcost',title:'Unit Cost',width:80,align:'right',sortable:true&#125;, &#123;field:'attr1',title:'Attribute',width:100&#125;, &#123;field:'status',title:'Status',width:60&#125; ]] title :列标题文本 field :列字段名 width :列的宽度,如果没有设置则表示自适应 rowspan :合并行 colspan :合并列 resizable :允许列改变大小 hidden :如果为true,表示隐藏 checkbox :如果为true则显示复选框对话窗口 12345678&lt;div class="easyui-dialog" style="width:600px;height:300px" data-options="title:'我的对话框',toolbar:'#tb',modal:true"&gt; 对话框窗口内容。里面可以插入一个表格&lt;/div&gt;&lt;div id="tb"&gt; &lt;a href="#" class="easyui-linkbutton" data-options="iconCls:'icon-edit',plain:true"/a&gt; &lt;a href="#" class="easyui-linkbutton" data-options="iconCls:'icon-help',plain:true"/a&gt;&lt;/div&gt; layout布局tab选项卡 1234567891011&lt;div id="tt" class="easyui-tabs" style="width:500px;height:250px;"&gt; &lt;div title="Tab1" style="padding:20px;display:none;"&gt; tab1 &lt;/div&gt; &lt;div title="Tab2" data-options="closable:true" style="overflow:auto;padding:20px;display:none;"&gt; tab2 &lt;/div&gt; &lt;div title="Tab3" data-options="iconCls:'icon-reload',closable:true" style="padding:20px;display:none;"&gt; tab3 &lt;/div&gt;&lt;/div&gt; tools 工具栏添加在选项卡面板头的左侧或右侧 1234567$('#tt').tabs(&#123; tools:'#tab-tools'&#125;);&lt;div id="tab-tools"&gt; &lt;a href="#" class="easyui-linkbutton" plain="true" iconCls="icon-add"&gt;&lt;/a&gt; &lt;a href="#" class="easyui-linkbutton" plain="true" iconCls="icon-save"&gt;&lt;/a&gt;&lt;/div&gt; onSelect 在选中一个选项卡时触发 onAdd 在添加一个选项卡时触发Accordion分类 12345678910111213&lt;div id="aa" class="easyui-accordion" style="width:300px;height:200px;"&gt; &lt;div title="Title1" data-options="iconCls:'icon-save'" style="overflow:auto;padding:10px;"&gt; &lt;h3 style="color:#0099FF;"&gt;Accordion for jQuery&lt;/h3&gt; &lt;p&gt;Accordion is a part of easyui framework for jQuery. It lets you define your accordion component on web page more easily.&lt;/p&gt; &lt;/div&gt; &lt;div title="Title2" data-options="iconCls:'icon-reload',selected:true" style="padding:10px;"&gt; content2 &lt;/div&gt; &lt;div title="Title3"&gt; content3 &lt;/div&gt; &lt;/div&gt; layout布局 完整页面布局 1234567&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'north',title:'North Title',split:true" style="height:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'south',title:'South Title',split:true" style="height:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'east',iconCls:'icon-reload',title:'East',split:true" style="width:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'west',title:'West',split:true" style="width:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'center',title:'center title'" style="padding:5px;background:#eee;"&gt;&lt;/div&gt; &lt;/body&gt; 嵌套布局 123456789&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'north'" style="height:100px"&gt;&lt;/div&gt; &lt;div data-options="region:'center'"&gt; &lt;div class="easyui-layout" data-options="fit:true"&gt; &lt;div data-options="region:'west',collapsed:true" style="width:180px"&gt;&lt;/div&gt; &lt;div data-options="region:'center'"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 布局面板加载外部数据&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'west',href:'west_content.php'" style="width:180px" &gt;&lt;/div&gt; &lt;div data-options="region:'center',href:'center_content.php'" &gt;&lt;/div&gt; &lt;/body&gt; 把布局面板区域添加指定面板 具体操作看面板 $('#cc').layout('add',{ region: 'west', width: 180, title: 'West Title', split: true, tools: [{ iconCls:'icon-add', handler:function(){alert('add')} },{ iconCls:'icon-remove', handler:function(){alert('remove')} }] }); 先写这么多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis_day02]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis-day02%2F</url>
      <content type="text"><![CDATA[定义resultMap如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。 resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 resultMap的配置 1234567&lt;resultMap type="com.yyt.mybatis.po.User" id="userListResultMap"&gt; &lt;id column="_id" property="id"/&gt; &lt;result column="_name" property="username"/&gt; &lt;result column="_birthday" property="birthday"/&gt; &lt;result column="_sex" property="sex"/&gt; &lt;result column="_address" property="address"/&gt;&lt;/resultMap&gt; 123&lt;select id="findUserListForResultMap" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT id _id,username _name,birthday _birthday,sex _sex,address _address FROM `user`&lt;/select&gt; 动态sql if语句 1234567891011&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user where 1=1 &lt;if test="id!=null"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; where语句 1234567891011&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach语句 向sql传递数组或List，mybatis使用foreach解析 mapper配置queryvo类中包括一个Integer集合ids 12345678910&lt;select id="findUserByForeach" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT * FROM USER WHERE username LIKE '%张%' &lt;!-- 判断queryvo对象里面的ids集合--&gt; &lt;if test="ids !=null and ids.size&gt;0"&gt; &lt;!-- 遍历ids,并非在上面sql语句上加入 and id in(......) 括号中间写遍历的参数以逗号隔开--&gt; &lt;foreach collection="ids" open="and id in(" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt; * 运行结果 * `Preparing: SELECT * FROM USER WHERE username LIKE &apos;%张%&apos; and id in( ? , ? , ? )` * `Parameters: 10(Integer), 89(Integer), 16(Integer)` sql片段 Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的 代码如下 1234567891011121314&lt;select id="findUserListForResultMap" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT id _id,username _name,birthday _birthday,sex _sex,address _address FROM `user` &lt;where&gt; &lt;include refid="id_username_user"/&gt; &lt;/where&gt;&lt;/select&gt;&lt;sql id="id_username_user"&gt; &lt;if test="user.id != null and user.id != ''"&gt; and id=$&#123;user.id&#125; &lt;/if&gt; &lt;if test="user.username != null and user.username != ''"&gt; and username like '%$&#123;user.username&#125;%' &lt;/if&gt;&lt;/sql&gt; 关联查询 一对一的查询一张订单对应只有一个用户 mapper代码 1234567891011121314151617181920212223242526272829303132&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type="Orders" id="orderUserResultMap"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 一对一关联映射 --&gt; &lt;!-- property:Orders对象的user属性 javaType：user属性对应 的类型 --&gt; &lt;association property="user" javaType="cn.itcast.po.User"&gt; &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="findOrdersWithUserResultMap" resultMap="orderUserResultMap"&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM orders o JOIN `user` u ON u.id = o.user_id&lt;/select&gt; * 在订单实体类中加入用户的属性,并提供get,set方法 一对多查询一个用户可以有多个订单 mapper代码 1234567891011121314151617181920212223242526&lt;!-- 配置一对多的关系 --&gt;&lt;resultMap type="user" id="userAndordersMapper"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="birthday" column="birthday"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="address" column="address"/&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property="orders" ofType="orders"&gt; &lt;id property="id" column="oid"/&gt; &lt;result property="number" column="number"/&gt; &lt;result property="createtime" column="createtime"/&gt; &lt;result property="note" column="note"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 一对多的sql语句的写法配置 --&gt;&lt;select id="findUserOrdersByUser" resultMap="userAndordersMapper"&gt; SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt; * 在用户实体类中加入订单对象的list集合属性,并提供get和set方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis_day01]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis-day01%2F</url>
      <content type="text"><![CDATA[Mybatis基本的配置 首先创建一个实体类并提供get,set和toString方法 12345678public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ........&#125; 加载log4j配置文件内容如下 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 在同级目录下创建接口和mapper配置文件两个文件的名称要相同 接口里面填写的是各种增删改查的方法 12345public interface UserMapper &#123; public User findUserByid(int id); public void insertUser(User user); public List&lt;User&gt; findAllUser();&#125; mapper配置文件的代码 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 这里因为接口和mapper文件都在同级目录,所以要填写本文件的包全路径 --&gt;&lt;mapper namespace="com.yyt.mybatis.mapper.UserMapper"&gt; &lt;!-- id:方法名,parameterType:传入方法里面的参数,resultType:方法执行后返回的参数类型 --&gt; &lt;select id="findUserByid" parameterType="int" resultType="com.yyt.mybatis.po.User"&gt; select * from `user` where id=#&#123;id&#125;; &lt;/select&gt; &lt;select id="insertUser" parameterType="com.yyt.mybatis.po.User"&gt; INSERT INTO USER(username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/select&gt; &lt;select id="findAllUser" resultType="com.yyt.mybatis.po.User"&gt; select * from `user`; &lt;/select&gt;&lt;/mapper&gt; mybatis核心配置文件的配置 SqlMapConfig.xml文件代码 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 链接数据库 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper class="com.yyt.mybatis.mapper.UserMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建一个测试类测试一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory = null; @Before public void init() throws Exception &#123; //第一步：创建一个SQLSessionFactoryBuilder对象。 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //第二步：加载配置文件。 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //第三步：创建SQLSessionFactory对象 sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testFindUserByid() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); User user = userMapper.findUserByid(1); sqlsession.close(); System.out.println(user); &#125; @Test public void testInsertUser() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); User user = new User(); user.setUsername("尼古拉斯赵四"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("湖北省武汉市江夏区汤逊湖北路8号长城科技园5栋1405"); userMapper.insertUser(user); sqlsession.commit(); sqlsession.close(); &#125; @Test public void testFindAllUser() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllUser(); sqlsession.close(); for (User user : list) &#123; System.out.println(user); &#125; &#125;&#125; #{}和${}的区别 1234/*#&#123;&#125;表示一个占位符号，通过#&#123;&#125;可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#&#123;&#125;可以有效防止sql注入。 #&#123;&#125;可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#&#123;&#125;括号中可以是value或其它名称。“%”#&#123;name&#125;”%”$&#123;&#125;表示拼接sql串，通过$&#123;&#125;可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， $&#123;&#125;可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，$&#123;&#125;括号中只能是value。*/ parameterType 指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中 resultType 指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象 selectOne 查询一条记录，如果使用selectOne查询多条记录则抛出异常 1234org.apache.ibatis.exceptions.TooManyResultsException:Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)-------------------------------没有找到selectOne方法的返回值,但发现了3个对象----------------------------- selectList 可以查询一条或多条记录。 SqlMapConfig配置文件里加载mapper映射文件有一下几种方法 &lt;mapper resource=&quot; &quot; /&gt; 使用相对于类路径的资源如： &lt;mapper class=&quot; &quot; /&gt; &lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt; 接口类路径 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 &lt;package name=&quot;&quot;/&gt; 注册指定包下的所有mapper接口 &lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 给mybatis配置别名 在SqlMapConfig.xml文件中配置 1234&lt;typeAliases&gt; &lt;!--配置别名, 填写实体类的路径 --&gt; &lt;package name="com.yyt.mybatis.po"/&gt;&lt;/typeAliases&gt; * 表示在该包路径中的实体类的别名就是他们的名字,不区分大小写. * 这样以后在mapper文件中的参数或者返回值类型就不用填写类的全路名了,直接填写别名就行了 mybatis支持的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis与spring的整合]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis%E4%B8%8Espring%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
      <content type="text"><![CDATA[SqlMapConfig.xml文件的配置 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 配置别名 --&gt; &lt;package name="com.yyt.mybayis.po"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapper class="com.yyt.mybayis.mapper.UserMapper"/&gt; &lt;mapper class="com.yyt.mybayis.mapper.OrdersMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; applicationContext.xml文件的配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载数据库参数配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 加载数据库信息 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 加载maybatis的核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:sqlmapConfig.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 分别配置两个mapper代理 --&gt; &lt;bean id="userMapperFactoryBean" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.yyt.mybayis.mapper.UserMapper"/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="ordersMapperFactoryBean" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.yyt.mybayis.mapper.OrdersMapper"/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; db.properties文件配置 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=123 测试方法 12345678910111213141516171819public class UserMapperTest &#123; private ApplicationContext applicationContext; @Before public void init() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void testFindAllUser() &#123; UserMapper userMapper = applicationContext.getBean(UserMapper.class); List&lt;User&gt; list = userMapper.findAllUser(); for (User user : list) &#123; System.out.println(user); &#125; &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
