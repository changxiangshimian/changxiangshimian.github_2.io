<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[struts2整合spring]]></title>
      <url>%2F2017%2F05%2F09%2Fstruts2%E6%95%B4%E5%90%88spring%2F</url>
      <content type="text"><![CDATA[spring的配置文件1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 自动代理 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt; &lt;property name="proxyTargetClass" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 切面 --&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt;&lt;/bean&gt; &lt;!-- 组件扫描 --&gt; &lt;context:component-scan base-package="com.yyt.bos"/&gt; &lt;!-- 支持spring注解(引入spring提供的注解解析器) --&gt; &lt;context:annotation-config/&gt; &lt;!-- 支持事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; 在web.xml文件下面添加如下配置123456789101112131415161718192021&lt;!-- 使用上下文参数指定spring配置文件的位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置spring框架的监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 配置struts2的过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;!-- 重定向的链接也通过此过滤器 --&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;!-- 转发的链接也通过此过滤器 --&gt;&lt;/filter-mapping&gt; 在struts.xml文件下的参数配置测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.devMode" value="false"&gt;&lt;/constant&gt;&lt;!-- 如果为true的话可以在代码编译运行的时候显示更多的信息:一般测试的时候用,上线就设置为false --&gt; &lt;!-- 把struts2交给spring管理 --&gt; &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt; &lt;!-- 国际化配置文件,在message文件里加载文件 --&gt; &lt;constant name="struts.custom.i18n.resources" value="message"&gt;&lt;/constant&gt;&lt;!-- 里面有登录信息的错误提示为key=value的形式 --&gt; &lt;package name="demo" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 先声明一个拦截器 --&gt; &lt;interceptor name="boslog" class="com.yyt.bos.web.interceptor.BOSLoginInterceptor"&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt;&lt;!-- 指定login方法不拦截 --&gt; &lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name="bos"&gt; &lt;!-- 加载上面的拦截器 --&gt; &lt;interceptor-ref name="boslog"&gt;&lt;/interceptor-ref&gt; &lt;!-- 加载默认的拦截器栈 --&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 设置默认的拦截器栈为上面设置的拦截器栈 --&gt; &lt;default-interceptor-ref name="bos"&gt;&lt;/default-interceptor-ref&gt; &lt;!-- 全局action --&gt; &lt;global-results&gt; &lt;!-- 全局的action --&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="page_*_*" &gt; &lt;result type="dispatcher"&gt;/WEB-INF/pages/&#123;1&#125;/&#123;2&#125;.jsp&lt;/result&gt;&lt;!-- 如果没有返回值默认返回的是success,dispatcher:转发到指定页面 --&gt; &lt;/action&gt; &lt;action name="userAction_*" class="userAction" method="&#123;1&#125;"&gt; &lt;result name="home"&gt;/WEB-INF/pages/common/index.jsp&lt;/result&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;result name="list"&gt;/login.jsp&lt;/result&gt; &lt;result name="addOk"&gt;WEB-INF/pages/admin/userlist.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="workordermanageAction_*" class="workordermanageAction" method="&#123;1&#125;"&gt; &lt;result name="list"&gt;/WEB-INF/pages/qupai/quickworkorder.jsp&lt;/result&gt; &lt;result name="showList"&gt;WEB-INF/pages/workflow/startransfer.jsp&lt;/result&gt; &lt;result name="start" type="redirectAction"&gt;workordermanageAction_showList.action&lt;/result&gt;&lt;!-- redirectAction:跳转到另一个action请求 --&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 声明拦截器类的方法1234567891011121314151617181920/* * 拦截器的方法 */public class BOSLoginInterceptor extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation arg0) throws Exception &#123; // TODO Auto-generated method stub //从session中获取登录用户 User user = (User) ServletActionContext.getRequest().getSession().getAttribute("user"); if(user != null)&#123; return arg0.invoke();//放行 &#125;else&#123; return "login"; &#125; //System.out.println("拦截器执行了"); &#125;&#125; action的代码要加上注释 @Controller @Scope(&quot;prototype&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试]]></title>
      <url>%2F2017%2F05%2F09%2F%E9%9D%A2%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Struts2 Struts2框架的执行流程 Hibernate hibernate是一个持久层的orm框架 持久层: 与数据库打交道的 orm:Object Relational Mapping。对象关系映射。开发语言用的是Java，面向对象的（Object）。使用的数据库是关系型数据库（Relational）。就是将对象与数据库中的表建立一种映射关系，操作对象就可以操作这个表。 hibernate与spring的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 自动代理 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt; &lt;property name="proxyTargetClass" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 读取jdbc.properties里面的键值对值 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"/&gt; &lt;property name="user" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/bean&gt; &lt;!-- 配置本地会话工厂 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!-- 数据库的方言 --&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt; &lt;!-- 配置显示SQL --&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;!-- 配置格式化SQL --&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;!-- 配置hbm2ddl --&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;!-- 设置事务的隔离级别 --&gt; &lt;prop key="hibernate.connection.isolation"&gt;4&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入hbm映射文件 --&gt; &lt;property name="mappingDirectoryLocations"&gt; &lt;list&gt; &lt;!-- 加载hibernate实体 --&gt; &lt;value&gt;classpath:com/yyt/bos/entity&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt;&lt;/beans&gt; hibernate 的执行流程 action层调用service层,service层调用dao层,dao类继承了HibernateDaoSupport 注解 @Repository this.getHibernateTemplate().find(hql,object…) 映射文件: 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Mapping file autogenerated by MyEclipse Persistence Tools--&gt;&lt;hibernate-mapping&gt; &lt;class name="com.yyt.bos.entity.Subarea" table="bc_subarea" catalog="zjs_bos"&gt; &lt;id name="id" type="java.lang.String"&gt; &lt;column name="id" length="32" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;many-to-one lazy="false" name="decidedzone" class="com.yyt.bos.entity.Decidedzone" fetch="select"&gt; &lt;column name="decidedzone_id" length="32" /&gt; &lt;/many-to-one&gt; &lt;many-to-one name="region" class="com.yyt.bos.entity.Region" fetch="select"&gt; &lt;column name="region_id" length="32" /&gt; &lt;/many-to-one&gt; &lt;property name="addresskey" type="java.lang.String"&gt; &lt;column name="addresskey" length="100" /&gt; &lt;/property&gt; &lt;property name="startnum" type="java.lang.String"&gt; &lt;column name="startnum" length="30" /&gt; &lt;/property&gt; &lt;property name="endnum" type="java.lang.String"&gt; &lt;column name="endnum" length="30" /&gt; &lt;/property&gt; &lt;property name="single" type="java.lang.String"&gt; &lt;column name="single" length="1" /&gt; &lt;/property&gt; &lt;property name="position" type="java.lang.String"&gt; &lt;column name="position" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Mapping file autogenerated by MyEclipse Persistence Tools--&gt;&lt;hibernate-mapping&gt; &lt;class name="com.yyt.bos.entity.Region" table="bc_region" catalog="zjs_bos"&gt; &lt;id name="id" type="java.lang.String"&gt; &lt;column name="id" length="32" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;property name="province" type="java.lang.String"&gt; &lt;column name="province" length="50" /&gt; &lt;/property&gt; &lt;property name="city" type="java.lang.String"&gt; &lt;column name="city" length="50" /&gt; &lt;/property&gt; &lt;property name="district" type="java.lang.String"&gt; &lt;column name="district" length="50" /&gt; &lt;/property&gt; &lt;property name="postcode" type="java.lang.String"&gt; &lt;column name="postcode" length="50" /&gt; &lt;/property&gt; &lt;property name="shortcode" type="java.lang.String"&gt; &lt;column name="shortcode" length="30" /&gt; &lt;/property&gt; &lt;property name="citycode" type="java.lang.String"&gt; &lt;column name="citycode" length="30" /&gt; &lt;/property&gt; &lt;set name="subareas" inverse="true"&gt; &lt;key&gt; &lt;column name="region_id" length="32" /&gt; &lt;/key&gt; &lt;one-to-many class="com.yyt.bos.entity.Subarea" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; mybatis mybatis 执行流程 mapper文件必须和接口名一致,方法名,里面的参数,和返回值类型要一一对应 mybatis核心配置文件里面配置别名,加载映射文件 在spring配置文件中配置sqlSessionFactoryBean其中注入数据库信息dataSource(dataSource链接数据库的),和mybatis的核心配置文件 配置mapper的代理(mapperFactoryBean)里面有两个peoperty,为sqlSessionFactory和mapperInterface springMVC springmvc spring执行流程:用户、前端控制器、处理器映射器、处理器适配器、视图解析器 web.xml配置 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 把配置文件springmvc.xml中的数据赋给DispatcherServlet --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc.xml配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 扫描controller配置,包扫描 --&gt; &lt;context:component-scan base-package="com.yyt.springmvc.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 视图 --&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;!-- 以某某开始 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 以某某结束 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- 文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 异常处理器 --&gt; &lt;bean id="handlerExceptionResolver" class="com.yyt.springmvc.exception.CustomExceptionResolver"/&gt;&lt;/beans&gt; applicationContext-service.xml配置 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 扫描controller配置,包扫描 --&gt; &lt;context:component-scan base-package="com.yyt.springmvc.service"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 其他知识点 jQuery选择器基本用法 $(&quot;p&quot;):所有 &lt;p&gt; 元素 $(&quot;p.intro&quot;):所有 class=”intro” 的 &lt;p&gt; 元素 $(&quot;.intro&quot;):所有 class=”intro” 的元素 $(&quot;#intro&quot;):id=”intro” 的元素 $(&quot;ul li:first&quot;):每个 &lt;ul&gt; 的第一个 &lt;li&gt; 元素 $(&quot;[href$=&#39;.jpg&#39;]&quot;):所有带有以 “.jpg” 结尾的属性值的href属性 $(&quot;div#intro .head&quot;):id=”intro” 的 &lt;div&gt; 元素中的所有 class=”head” 的元素 点击按钮触发一个函数,隐藏所有&lt;p&gt;元素 $(&quot;button&quot;).click(function() { $(&quot;p&quot;).hide(); } ) $(&quot;#id&quot;).hide(1000);:以1000毫秒的速度隐藏元素 $(&quot;#id&quot;).show():显示元素 $(&quot;span&quot;).parents(&quot;ul&quot;):返回所有 &lt;span&gt; 元素的所有祖先，并且它是 &lt;ul&gt; 元素 $(&quot;span&quot;).parentsUntil(&quot;div&quot;):介于 &lt;span&gt; 与 &lt;div&gt; 元素之间的所有祖先元素 $(&quot;div&quot;).children(): &lt;div&gt; 元素的所有直接子元素 $(&quot;div&quot;).children(&quot;p.1&quot;):返回类名为 “1” 的所有 &lt;p&gt; 元素，并且它们是 &lt;div&gt; 的直接子元素 find() 方法返回被选元素的后代元素，一路向下直到最后一个后代 $(&quot;div&quot;).find(&quot;span&quot;):返回属于 &lt;div&gt; 后代的所有 &lt;span&gt; 元素 $(&quot;div&quot;).find(&quot;*&quot;):返回 &lt;div&gt; 的所有后代 $(&quot;h2&quot;).siblings():返回 &lt;h2&gt; 的所有同胞元素 $(&quot;h2&quot;).siblings(&quot;p&quot;):返回属于 &lt;h2&gt; 的同胞元素的所有 &lt;p&gt; 元素 $(&quot;h2&quot;).next():返回 &lt;h2&gt; 的下一个同胞元素 $(&quot;h2&quot;).nextAll():返回 &lt;h2&gt; 的所有跟随的同胞元素 ajax: 它在不重载全部页面的情况下，AJAX 通过后台加载数据，并在网页上进行显示 12345678910$("button").click(function()&#123; $.post("demo_test_post.asp", &#123; name:"Donald Duck", city:"Duckburg" &#125;, function(data,status)&#123; alert("Data: " + data + "\nStatus: " + status); &#125;);&#125;); jstl核心标签&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;c:set&gt; 标签 value:要存储的值 var:存储信息的变量 scope:var属性的作用域 123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;c:set 标签实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;p&gt;$&#123;salary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;c:if&gt; 标签 test:条件 12345&lt;body&gt;&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;c:if test="$&#123;salary &gt; 2000&#125;"&gt; &lt;p&gt;我的工资为: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;p&gt;&lt;/c:if&gt; &lt;c:forEach&gt; 标签 items:要被循环的额信息 var:代表当前条目的变量名称 12345&lt;body&gt;&lt;c:forEach var="list" items="$&#123;List&#125;"&gt; &lt;p&gt;list&lt;/P&gt;&lt;/c:forEach&gt;&lt;/body&gt; Request类常用方法 12345678910111. setAttribute()在Request域中存储数据2. setCharacterEncoding()设置请求参数的编码方式,只对post请求有效3. getMethod()获取请求类型4. getParameter()获取指定请求参数值5. getParameterNames()获取所有请求参数,返回一个Enumeration枚举类6. getAttribute()获取域中存储的数据7. getAttributeNames()获取域中所有数据,返回一个Enumeration枚举类8. getContextPath()返回当前WEB项目相对路径9. getCookies()获取所有Cookie,返回一个Cookie数组10. getRequestDispatcher()获取转发器,参数路径以/打头,代表WebRoot(当前WEB项目根目录)11. getSession()获取Session对象 Response类常用方法 123456781. setContentType()告知浏览器数据类型2. setCharacterEncoding设置Response的编码方式3. setHeader()设置消息头4. setStatus()设置状态吗5. addCookie()添加Cookie6. sendRedirect()重定向7. getOutputStream()获取通向浏览器的字节流(同一次请求处理中,字节流和字符流不能同时存在)8. getWriter()获取通向浏览器的字符流(同一次请求处理中,字节流和字符流不能同时存在) sql基础命令 建表命令：CREATE TABLE tableName(id int not null default 0 primary key,name char(20) default &#39;1&#39;); 表插入数据:insert into tableName (列名1,列名2) values (值1,值2); 删除数据:DELETE FROM tableName WHERE xx=xx; 修改表中的数据:UPDATE tableName SET (列名=列值) WHERE xx=xx； 分页查找:select *from 表名 limit 每页数量 offset 偏移量; MYSQL数据库导入导出 导入：mysql -uroot -ptian test&lt;test.sql 导出：mysqldump -uroot -ptian test&gt;test.sql 说出Servlet的生命周期，并说出Servlet和CGI的区别 1234Web 容器加载Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其init（初始化）方法进行Servlet 的初始化，请求到达时运行其service 方法，service方法自动运行与请求对应的doXXX 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy 方法。与cgi 的区别在于servlet 处于服务器进程中，它通过多线程方式运行其service 方法，一个实例可以服务于多个请求，并且其实例不会销毁，而CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 重定向和转发的区别 重定向时浏览器上的网址改变，转发是浏览器上的网址不变 重定向实际上产生了两次请求，转发只有一次请求 重定向时的网址可以是任何网址，转发的网址必须是本站点的网址 转发可以保存一些作用域的值，重定向不能保存作用域的值 对MVC的理解 MVC:即model（模型）、view（视图）、control（控制）分离设计 Model：即处理业务逻辑的模块，每一种处理一个模块；包括(业务逻辑和数据访问代码) View：负责页面显示，显示MODEL 处理结果给用户，主要实现数据到页面转换过程；包括：jsp、jstl、freemarketr Control：负责每个请求的分发，把FORM 数据传递给MODEL 处理，把处理结果的数据传递给VIEW 显示。一般是用Servlet或Filter代替 Spring中IOC、AOP的含义 123456IOC：就是容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在。控制权由应用代码中转到了外部容器(Spring)，控制权的转移是所谓反转。IOC还有另外一个名字——“依赖注入（Dependency Injection）”。从名字上理解，即组件之间的依赖关系由容器在运行期决定，形象地说，即由容器动态地将某种依赖关系注入到组件之中。AOP：面向切面编程 将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。 比如： 很多方法可能会抛异常，你要记录这个异常到日志中去，可以写个拦截器类，在这个类中记录日志，在spring.xml中配置一个对这些要记录日志的方法的aop拦截器 在这个方法执行后调用这个拦截器，记录日志。这样就不用每次抛异常都要手动记录日志 Spring依赖注入有几种方式？AOP的代理有几种? Spring依赖注入有有种：1 构造器注入 2 setter方法注入 3 接口注入 AOP的代理有几种：1 JDK动态代理，2 CGLIB代理 JSP内置对象有哪些 request, response, out, session, application, config, pagecontext, page, exception 单例模式 123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125; &#125; 工厂模式 定义一个接口为动物走路,里面有run方法 有两个类实现了该接口分别为狗和猫,并分别重写了run方法 定义一个工厂,里面有个方法,该方法判断形参是猫还是狗,然后根据多态返回一个动物类 在主方法里面调用该工厂,并输入参数,会返回一个动物类 装饰者模式 组合与聚合 单一职责 123456单一职责原则(SRP:Single responsibility principle)又称单一功能原则，面向对象五个基本原则(SOLID)之一。它规定一个类应该只有一个发生变化的原因。单一职责原则是最简单的面对对象设计原则，它用于控制类的粒度大小。在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。我们写程序的目标就是 高内聚 低耦合!什么叫高内聚低耦合呢，举个例子：你房子里边有墙和窗 ，那墙和窗就有了关联，耦合度 是松还是紧 就看你的 关联 是强还是弱，也就是修改的代价，比如 你窗是扣死在墙里的 那么你修改窗子就必须修改墙 这就比较紧密了，但是如果你窗是按照某种规格的 可以自由拆装的 那么修改的代价就小，耦合度也就低了。 组合与聚合(一般能用组合与聚合的尽量别用继承,继承耦合度高) 1在一个类里面,创建一个方法,里面创建另一个类的对象,并调用里面其他的方法,如果想扩展,就直接在下面写 oracle分页比如查询第20到30条的数据 123456select *from ( select rownum r,empno,ename,hiredate from ( select * from emp where rownum&lt;=30 order by hiredate ) ) where r&gt;=20 order by hiredate 什么是JDBC及JDBC访问数据库过程 JDBC是一种用于执行SQL语句的Java API,它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准 1234561、加载对应数据库驱动，一般用反射Class.forName(String driverName); 2、创建连接通过DriverManager.getConnection(url,userName,passwd); 3、获取statement对象，通过statement对象执行sql语句； 4、如果是查询则返回结果集，贮存于ResultSet； 5、如果关闭事物自动提交要提交事物； 6、最后，关闭所有连接，自里往外关闭。 你对Hibernate的理解 123Hibernate是一个开放源代码的对象关系映射框架(ORM)，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用 什么是ORM 1对象关系映射,目前数据库是关系型数据库,ORM 主要是把数据库中的关系数据映射称为程序中的对象，从而简化大量的jdbc代码 编码转换：怎样将GB2312 编码的字符串转换为ISO-8859-1 编码的字符串 12String s = "s";s = new String(s.getBytes("iso-8859-1"), "GB2312"); 列出你知道的：DML,DCL,DDL 123DML数据操作语言：SELECT、INSERT、UPDATE、DELETEDCL数据控制语言： GRANT、REVOKEDDL数据定义语言：CREATE、ALTER、DROP、RENAME、TRUNCATE、COMMENT wait()和sleep()区别 sleep是让线程指定休眠时间，然后继续工作 wait则是等待，直到有线程通知notify（）唤醒他才会重新工作 * ssh框架 12345678SSH框假中spring充当了管理容器的角色。我们都知道Hibernate用来做持久层，因为它将JDBC做了一个良好的封装，程序员在与数据库进行交互时可以不用书写大量的SQL语句。Struts是用来做应用层的，他它负责调用业务逻辑serivce层。所以SSH框架的流程大致是：Jsp页面----Struts------Service（业务逻辑处理类）---Hibernate（左到右） struts负责控制Service（业务逻辑处理类），从而控制了Service的生命周期，这样层与层之间的依赖很强，属于耦合。这时，使用spring框架就起到了控制Action对象（Strus中的）和Service类的作用，两者之间的关系就松散了，Spring的Ioc机制（控制反转和依赖注入）正是用在此处。 Hibernate 的分页 1234Query query = session.createQuery("from Student");query.setFirstResult(firstResult);//设置每页开始的记录号query.setMaxResults(resultNumber);//设置每页显示的记录数Collection students = query.list(); 项目 erp系统:为企业员工及决策层提供决策手段的管理平台 b2c:商家对直接向消费者出售产品或者服务 soa架构:面向服务的体系结构 maven:分布式 首页的并发量比较高,对数据库的压力比较大,采用了redis缓存 首页运用了cms(内容管理系统),从后台更改前台页面的元素 模块 前台 后台 会员 订单 搜索 登录 使用solr建立索引来搜索商品 添加商品:索引也要全部重新添加,速度慢;采用activemq消息队列解决 每次添加新的商品,发一个消息,在另一个工程做一个activemq监听器,只要接收到消息就只向solr索引里面添加指定的内容 登录信息保存在redis中 模拟单点登录 在添加购物车时,如果用户没有登录,就把购物车的信息放到cookie中 点击提交订单时,让用户登录,并把购物车里面的内容存放到数据库中,再根据数据库中的购物车里面的物品生成订单 如果用户登录了,就把购物车里面的商品直接添加到数据库中 搜索solr 可以设置搜索的产品的权重,来竞价排名 上架商品或修改商品时也可以利用页面静态化技术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dubbo官方文档]]></title>
      <url>%2F2017%2F05%2F07%2Fdubbo%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[dubbo网址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis的使用]]></title>
      <url>%2F2017%2F05%2F07%2Fredis%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[CentOS下安装redis因为redis是由c语言编写的,CentOS要编译redis的话要安装gcc 执行命令Yum install gcc-c++ 把redis的安装包拷贝到CentOS上把redis解压缩进到redis目录下运行make命令进行编译安装redis执行make install PREFIX=/usr/local/redis命令,把redis安装到/usr/local/redis目录下启动redis先把redis源码包里面的redis.conf文件复制到/usr/local/redis/bin目录下就是redis的安装目录下的bin目录编辑redis.conf文件vim redis.conf 运行./redis-server redis.conf命令查看redis进程看是否已经运行ps aux|grep redis 关闭redis运行命令./redis-cli shutdown链接redis客户端服务 ./redis-cli 默认连接localhost运行在6379端口的redis服务 ./redis-cli -h 192.168.25.153 -p 6379 链接指定ip下该端口的redis服务 -h：连接的服务器的地址 -p：服务的端口号 redis中所有的数据都是字符串,命令不区分大小写,key是区分大小写的,redis是单线程的,redis中不适合保存内容较大的数据Redis五种数据类型String：key-value（做缓存） get,set incr:加一 (生成id) decr:减一 Hash：key-fields-values（做缓存） 相当于一个key对应一个map,map中还有key-value 使用hash对key进行归类 hset,hget 123456&gt; hset hash1 field1 1(integer) 1&gt; hset hash1 field2 2(integer) 1&gt; hget hash1 field2&quot;2&quot; List：有顺序可重复里面没有key只有元素 lpush从左边开始向里面添加数据 rpush从右边开始向里面添加数据 lrange从左边开始读取数据 lpop从左边取数据:取出后最左边的数据就没了因为已经取走了,从右取同理 rpop从右边取数据 1234567&gt; lpush list a b c d(integer) 4&gt; lrange list 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot; Set：无顺序，不能重复 sadd向set里面添加元素 smembers 查看set里面的元素 srem删除set里面的指定元素 1234567891011&gt; sadd set1 a b c d d f g f(integer) 6&gt; smembers set11) &quot;b&quot;2) &quot;d&quot;3) &quot;g&quot;4) &quot;a&quot;5) &quot;f&quot;6) &quot;c&quot;&gt; srem set1 a1 SortedSet（zset:用于排序）：有顺序，不能重复 zadd向zset中添加元素,每个元素前面都有一个分数,排序用 zrange查看zset中的元素 从小到大查看 zrevrange查看zset中的元素 从大到小查看 zrem删除指定元素 withscores在查看语句的后面加上:取出元素的同时也会把分数取出来 1234567891011121314151617181920&gt; zadd zset1 2 a 5 b 1 c 6 d(integer) 4&gt; zrange zset1 0 -11) &quot;c&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;d&quot;&gt; zrem zset1 a1&gt; zrevrange zset1 0 -11) &quot;d&quot;2) &quot;b&quot;3) &quot;c&quot;&gt; zrange zset1 0 -1 withscores1) &quot;c&quot;2) 1.03) &quot;b&quot;4) 5.05) &quot;d&quot;6) 6.0 给key设置过期时间 expire设置过期时间,以秒为单位 12&gt; expire key1 50(integer) 1 ttl查看指定key的过期状态:如果返回的数为-2则表示该key不存在或已经过期,如果返回值为-1则表示改key为持久状态 12&gt; ttl key1(integer) 44 persist把设置过期时间的key但未过期的状态修改为持久态 12&gt; persist key2(integer) 1 redis的持久化方案 redis的所有缓存数据都是保存在内存中的(但它有两种持久化的方案) rdb:快照形式,定期的把内存中当前时刻的数据保存到磁盘(默认支持的方案 性能高) aof形式:append only file.把所有对redis数据库操作的命令,增删改操作的命令保存到文件中.数据库回复时把所欲的命令都执行一遍(性能低) rdb形式的配置:修改redis.conf文件 aof形式配置:修改redis.conf文件并重启 两种方案同时开启会采用aof方案来持久化 redis集群版的搭建:至少搭建6个redis集群 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽. 节点的fail是通过集群中超过半数的节点检测失效时才生效. 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可 redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护 1234Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 步骤: 把配置好的单机版redis目录下的bin目录复制到redis-cluster/redis01~redis06目录中去:并把持久化文件删掉 修改redis.conf中的配置文件,把端口号改掉,把6379端口号分别换成其它的,并把cluster-enabled前面的注释打开 创建一个批处理文件start-all.sh 把6个reids的启动命令写在里面 把start-all.sh文件变为可执行文件 chmod u+x start-all.sh 安装ruby yum install ruby yum install rubygems 安装ruby脚本运行使用的包 gem install redis-3.0.0.gem 执行完成后在redis-3.0.0目录下的src目录下查找redis-trib.rb文件把该文件拷贝到redis-cluster目录下 使用ruby脚本搭建集群执行下面命令:根据情况修改ip和端口号 1./redis-trib.rb create --replicas 1 192.168.25.129:7001 192.168.25.129:7002 192.168.25.129:7003 192.168.25.129:7004 192.168.25.129:7005 192.168.25.129:7006 链接集群链接任意一个集群的端口就行 redis01/redis-cli -p 7001 -c jedis操作redis数据(测试) 导入依赖 12345&lt;!-- jedis客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 链接单机版 123456789//链接单机版@Testpublic void testSingle()&#123; Jedis jedis = new Jedis("192.168.25.129",6379); jedis.set("key1","test1"); System.out.println(jedis.get("key1")); jedis.close(); &#125; 链接池链接单机版 12345678910//连接池链接单机版@Testpublic void testSingle2()&#123; JedisPool jedispool = new JedisPool("192.168.25.129",6379); Jedis jedis = jedispool.getResource(); jedis.set("key2", "test2"); System.out.println(jedis.get("key2")); jedis.close(); jedispool.close();&#125; 使用jedis操作集群 1234567891011121314151617//使用jedis操作集群@Testpublic void testCluster()&#123; //创建一个Set&lt;HostAndPort&gt;参数 redis节点的列表 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;(); nodes.add(new HostAndPort("192.168.25.129", 7001)); nodes.add(new HostAndPort("192.168.25.129", 7002)); nodes.add(new HostAndPort("192.168.25.129", 7003)); nodes.add(new HostAndPort("192.168.25.129", 7004)); nodes.add(new HostAndPort("192.168.25.129", 7005)); nodes.add(new HostAndPort("192.168.25.129", 7006)); //创建一个集群对象JedisCluster JedisCluster cluster = new JedisCluster(nodes); cluster.set("hello", "100"); System.out.println(cluster.get("hello")); cluster.close();&#125; jedis整合spring因为我们测试的时候一般用单机版,上线时一般用集群版,这两者在操作上又有很大的区别所以我们一般写一个接口,单机版和集群版都实现了这个接口 接口代码 123456789101112public interface JedisClient &#123; String set(String key, String value); String get(String key); Boolean exists(String key); Long expire(String key, int seconds); Long ttl(String key); Long incr(String key); Long hset(String key, String field, String value); String hget(String key, String field); Long hdel(String key, String... field);&#125; 集群代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JedisClientCluster implements JedisClient &#123; @Autowired private JedisCluster jedisCluster; @Override public String set(String key, String value) &#123; return jedisCluster.set(key, value); &#125; @Override public String get(String key) &#123; return jedisCluster.get(key); &#125; @Override public Boolean exists(String key) &#123; return jedisCluster.exists(key); &#125; @Override public Long expire(String key, int seconds) &#123; return jedisCluster.expire(key, seconds); &#125; @Override public Long ttl(String key) &#123; return jedisCluster.ttl(key); &#125; @Override public Long incr(String key) &#123; return jedisCluster.incr(key); &#125; @Override public Long hset(String key, String field, String value) &#123; return jedisCluster.hset(key, field, value); &#125; @Override public String hget(String key, String field) &#123; return jedisCluster.hget(key, field); &#125; @Override public Long hdel(String key, String... field) &#123; return jedisCluster.hdel(key, field); &#125;&#125; 单机版代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class JedisClientPool implements JedisClient &#123; @Autowired private JedisPool jedisPool; @Override public String set(String key, String value) &#123; Jedis jedis = jedisPool.getResource(); String result = jedis.set(key, value); jedis.close(); return result; &#125; @Override public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String result = jedis.get(key); jedis.close(); return result; &#125; @Override public Boolean exists(String key) &#123; Jedis jedis = jedisPool.getResource(); Boolean result = jedis.exists(key); jedis.close(); return result; &#125; @Override public Long expire(String key, int seconds) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.expire(key, seconds); jedis.close(); return result; &#125; @Override public Long ttl(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.ttl(key); jedis.close(); return result; &#125; @Override public Long incr(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.incr(key); jedis.close(); return result; &#125; @Override public Long hset(String key, String field, String value) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.hset(key, field, value); jedis.close(); return result; &#125; @Override public String hget(String key, String field) &#123; Jedis jedis = jedisPool.getResource(); String result = jedis.hget(key, field); jedis.close(); return result; &#125; @Override public Long hdel(String key, String... field) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.hdel(key, field); jedis.close(); return result; &#125;&#125; 在spring配置文件中配置jedis的相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 单机版 --&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="6379"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisClientPool" class="com.taotao.content.jedis.JedisClientPool"/&gt; &lt;!-- 集群版 --&gt;&lt;!-- &lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg name="nodes"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7001"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7002"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7003"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7004"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7005"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.129"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7006"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="jedisClientCluster" class="com.taotao.content.jedis.JedisClientCluster"&gt;&lt;/bean&gt; --&gt;&lt;/beans&gt; 测试代码 123456789//redis与spring整合@Testpublic void testJedisClientPool()&#123; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-*.xml"); JedisClient jedisClient = applicationContext.getBean(JedisClient.class); jedisClient.set("key5", "haha"); System.out.println(jedisClient.get("key5")); applicationContext.close();&#125; 这样以后切换集群版和单机版就可以不用修改java代码了,只用注释掉spring配置文件里面的集群或者单机的配置文件里面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActiveMQ]]></title>
      <url>%2F2017%2F05%2F06%2FActiveMQ%2F</url>
      <content type="text"><![CDATA[ActiveMQ的介绍 MQ是一个消息中间件 ActiveMQ RabbitMQ kafka :一般用于大数据 什么是ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。 特点 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务) 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA 支持通过JDBC和journal提供高速的消息持久化 从设计上保证了高性能的集群,客户端-服务器,点对点 支持Ajax 支持与Axis的整合 可以很容易得调用内嵌JMS provider,进行测试 ActiveMQ的消息形式 点对点的:即一个生产者和一个消费者一一对应 发布/订阅模式:即一个生产者产生消息并进行发送后，可以由多个消费者进行接收 MQ允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 StreamMessage – Java原始值的数据流 MapMessage–一套名称-值对 TextMessage–一个字符串对象 ObjectMessage–一个序列化的 Java对象 BytesMessage–一个字节的数据流 ActiveMQ的安装解压安装包 进入到apache-activemq-5.12.0/bin目录下运行activemq start命令 在浏览器地址输入地址http://192.168.25.129:8161/admin/用户名和密码都为admin 修改host文件执行vim /etc/hosts不添加会报503错误 测试activeMQ在工程中添加依赖12345&lt;!-- 添加activeMQ客户端依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;&lt;/dependency&gt; 建一个测试类:测试queue-producer 发送者12345678910111213141516171819202122232425262728public class testmq &#123; @Test public void testmq() throws Exception&#123; //创建一个连接工厂ConnectionFactory对象指定ip和端口号 ConnectionFactory connectionFactory =new ActiveMQConnectionFactory("tcp://192.168.25.129:61616"); //使用ConnectionFactory创建一个Connection对象 Connection connection = connectionFactory.createConnection(); //开启连接,调用start方法 connection.start(); //使用Connection对象创建一个Session对象 //第一个参数:开启事务,一般不开启.当为false时,第二个参数才有意义 //第二个参数:消息应答模式.手动应答;自动应答,一般使用自动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //使用Session对象创建一个Destination,目的地有两种queue,topic Queue queue = session.createQueue("test-queue"); //使用Session对象创建一个Producer对象 MessageProducer prouducer = session.createProducer(queue); //使用producer发送消息 /*TextMessage textMessage = new ActiveMQTextMessage(); textMessage.setText("使用activemq发送队列消息");*/ TextMessage textMessage = session.createTextMessage("再次发送消息"); prouducer.send(textMessage); //关闭资源 prouducer.close(); session.close(); connection.close(); &#125;&#125; 效果 建一个测试类:测试queue-consumer 接收者12345678910111213141516171819202122232425262728293031323334353637383940414243public class testmq &#123; @Test public void testConsumer() throws Exception &#123; // 创建一个连接工厂ConnectionFactory对象指定ip和端口号 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.129:61616"); // 使用ConnectionFactory创建一个Connection对象 Connection connection = connectionFactory.createConnection(); // 开启连接,调用start方法 connection.start(); // 使用Connection对象创建一个Session对象 // 第一个参数:开启事务,一般不开启.当为false时,第二个参数才有意义 // 第二个参数:消息应答模式.手动应答;自动应答,一般使用自动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 使用Session对象创建一个Destination,目的地有两种queue,topic Queue queue = session.createQueue("test-queue"); // 使用session创建一个消费者 MessageConsumer consumer = session.createConsumer(queue); // 使用消费者接收消息 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; try &#123; // 打印消息 TextMessage textMessage = (TextMessage) message; String text = null; text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //进行等待 System.in.read(); //关闭资源 consumer.close(); session.close(); connection.close(); &#125;&#125; 建一个测试类:测试topic-producer 发送者123456789101112131415161718192021222324252627282930313233public class testmq &#123; @Test public void testTopicProducer() throws Exception &#123; // 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。 // brokerURL服务器的ip及端口号 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.129:61616"); // 第二步：使用ConnectionFactory对象创建一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接，调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 // 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。 // 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。 // 参数：话题的名称。 Topic topic = session.createTopic("test-topic"); // 第六步：使用Session对象创建一个Producer对象。 MessageProducer producer = session.createProducer(topic); // 第七步：创建一个Message对象，创建一个TextMessage对象。 /* * TextMessage message = new ActiveMQTextMessage(); message.setText( * "hello activeMq,this is my first test."); */ TextMessage textMessage = session.createTextMessage("创建一个topic发送者"); // 第八步：使用Producer对象发送消息。 producer.send(textMessage); // 第九步：关闭资源。 producer.close(); session.close(); connection.close(); &#125;&#125; 建一个测试类:测试topice-consumer 接收者1234567891011121314151617181920212223242526272829303132333435363738394041public class testmq &#123; @Test public void testTopicConsumer() throws Exception &#123; // 第一步：创建一个ConnectionFactory对象。 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.129:61616"); // 第二步：从ConnectionFactory对象中获得一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接。调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。 Topic topic = session.createTopic("test-topic"); // 第六步：使用Session对象创建一个Consumer对象。 MessageConsumer consumer = session.createConsumer(topic); // 第七步：接收消息。 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; String text = null; // 取消息的内容 text = textMessage.getText(); // 第八步：打印消息。 System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println("topic的消费端03。。。。。"); // 等待键盘输入 System.in.read(); // 第九步：关闭资源 consumer.close(); session.close(); connection.close(); &#125;&#125; activeMQ整合spring发送消息pom文件中需要引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;&lt;/dependency&gt; 配置spring的配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.129:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!-- 配置生产者 --&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="spring-queue" /&gt; &lt;/bean&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="spring-topic" /&gt; &lt;/bean&gt;&lt;/beans&gt; 建立一个测试类12345678910111213141516171819202122public class TestSpringActivemq &#123; @Test public void testQueueProducter()&#123; //初始化spring容器 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:/spring/applicationContext-activemq.xml"); //从容器中获取JMSTemplate对象 JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class); //从容器中获得Destination对象 Queue queue = applicationContext.getBean(Queue.class); //参数1:指定发送的目的地 //参数2:消息的构造器对象 jmsTemplate.send(queue,new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; // TODO Auto-generated method stub TextMessage textMessage = session.createTextMessage("使用spring和activemq整合发送queue消息"); return textMessage; &#125; &#125;); &#125;&#125; activeMQ整合spring接收消息加入activemq的客户端依赖12345&lt;!-- 添加activeMQ客户端依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个MessageListener的实现类1234567891011121314151617public class MyMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; // TODO Auto-generated method stub try &#123; TextMessage textMessage = (TextMessage) message; //取消息内容 String text = textMessage.getText(); System.out.println(text); //其它业务 &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 配置spring整合activemq的配置文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.129:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="spring-queue" /&gt; &lt;/bean&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="spring-topic" /&gt; &lt;/bean&gt; &lt;!-- 接收消息 --&gt; &lt;!-- 配置监听器 --&gt; &lt;bean id="myMessageListener" class="com.taotao.search.listener.MyMessageListener" /&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试接收消息的代码1234567@Testpublic void testQueueConsumer() throws Exception &#123; //初始化spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml"); //等待 System.in.read();&#125; 先开启接收的测试代码,然后开启发送端的测试代码,就可以利用监听器接收消息了添加商品同步索引库 在添加商品的时候,把商品的id发送到其它项目,然后根据商品id查询表把表中的数据添加到索引库中去 在添加商品的代码中加上代码如下123456//先注入对象@Autowiredprivate JmsTemplate jmsTemplate;@Autowiredprivate Topic topic; 123456789jmsTemplate.send(topic,new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; // TODO Auto-generated method stub TextMessage textMessage = session.createTextMessage(itemId+"");//商品的id 要转为字符串 return textMessage; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建solr集群]]></title>
      <url>%2F2017%2F05%2F05%2F%E6%90%AD%E5%BB%BAsolr%E9%9B%86%E7%BE%A4%2F</url>
      <content type="text"><![CDATA[什么是SolrCloud SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud来满足这些需求。 SolrCloud是基于Solr和Zookeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。 特色功能 集中式的配置信息 自动容错 近实时搜索 查询时自动负载均衡 Solr集群的系统架构 案例实现的solr集群架构 需要三个zookeeper节点 需要四个tomcat节点 建议虚拟机的内存1G以上 搭建zookeeper集群解压zookeeper 把zookeeper复制三分 在三个zookeeper里面创建一个data目录 在data目录下面创建一个myid文件,并向本zookeeper的myid文件里面写入1,第二个写入2,第三个写入3… echo 12345 &gt;&gt; myid也可以创建一个文件,并向文件中把12345写入到文件中 cat myid可以查看myid里面的文件内容 并把zookeeper下的conf文件夹下的zoo_sample.cfg文件改名为zoo.cfg mv zoo_sample.cfg zoo.cfg 修改zoo.cfg文件 还有两个zookeeper配置修改 与第一个不同:myid里面的内容依次加一;zoo.cfg配置文件里面的dataDir路径修改一下;clientport端口不要与其他两个冲突;server.1,server.2,server.3不用修改直接拷过来 在solr-cloud目录下创建一个命令集 并把startall-zookeeper-all.sh状态修改为可执行状态 运行命令集,启动集群 搭建solr集群复制4份tomcat到solr-cloud目录下 修改tomcat下conf目录下的server.xml文件中的port参数 剩下的几个tomcat下的server.xml文件参数分别把要改的地方的第二位数加一,做到不冲突就行 把搭建好的单机版solr拷贝到集群中的四个tomcat中 把搭建好的单机版solrhome拷贝4份到solr-cloud中 修改四个solrhome里面的solr.xml文件 修改四个tomcat下的solr工程中的web.xml文件 使用工具上传配置文件 进到 ~/solr-4.x.x/example/scripts/cloud-scripts目录下执行以下命令 1./zkcli.sh -zkhost 192.168.25.129:2182,192.168.25.129:2183,192.168.25.129:2184 -cmd upconfig -confdir /usr/local/solr-cloud/solr_home01/collection1/conf -confname myconf 命令运行完后进到/usr/local/solr-cloud/zookeeper01/bin目录下执行命令 ./zkCli.sh -server localhost:2182 以2182端口启动 如果执行./zkCli.sh命令的话默认是以2181启动的,2181是单机版的 quit退出 zookeeper与solr建立关系修改四个tomcat/bin目录下的catalina.sh文件 搜索JAVA_OPTS并在下面位置添加该参数 修改了四个tomcat中的catalina.sh文件后,依次启动四个tomcat 然后在浏览器中输入http://192.168.25.129:8180/solr/得到如下 创建新的Collection进行分片处理 在浏览器地址输入http://192.168.25.129:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 刷新http://192.168.25.129:8180/solr/网址 删除不用的Collection :在浏览器地址处输入http://192.168.25.129:8180/solr/admin/collections?action=DELETE&amp;name=collection1 刷新http://192.168.25.129:8180/solr/网址 使用solrJ操作solrcloud:solr集群1234567891011121314151617181920public class TestSolrCould &#123; @Test public void demo1() throws Exception, IOException &#123; // 创建一个CloudSolrServer对象 CloudSolrServer cloudSolrServer = new CloudSolrServer("192.168.25.129:2182,192.168.25.129:2183,192.168.25.129:2184"); //构造方法有一个参数,zkHost,字符串类型zookeeper的地址列表 //指定默认的Collection cloudSolrServer.setDefaultCollection("collection2"); // 创建一个文档对象 SolrInputDocument SolrInputDocument document = new SolrInputDocument(); // 向文件中添加域 document.addField("id", "test001"); document.addField("item_title", "商品测试"); document.addField("item_price", 100); // 把文档写入索引库 cloudSolrServer.add(document); // 提交 cloudSolrServer.commit(); &#125;&#125; 把服务切换到集群上 在spring配置文件中把solr单机版换成集群版 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt; &lt;!-- solr单机版 --&gt; &lt;!-- &lt;bean id=&quot;httpSolrServer&quot; class=&quot;org.apache.solr.client.solrj.impl.HttpSolrServer&quot;&gt; &lt;constructor-arg name=&quot;baseURL&quot; value=&quot;http://192.168.25.129:8080/solr&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; --&gt; &lt;!-- solr集群 --&gt; &lt;bean id=&quot;cloudSolrServer&quot; class=&quot;org.apache.solr.client.solrj.impl.CloudSolrServer&quot;&gt; &lt;constructor-arg name=&quot;zkHost&quot; value=&quot;192.168.25.129:2182,192.168.25.129:2183,192.168.25.129:2184&quot;&gt;&lt;/constructor-arg&gt; &lt;property name=&quot;defaultCollection&quot; value=&quot;collection2&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 异常处理 为了避免把异常抛给用户,我们一般要做异常处理 处理思路 创建全局异常处理器 1234567891011121314151617public class GlobalExceptionResolver implements HandlerExceptionResolver&#123; private static Logger logger = Logger.getLogger(GlobalExceptionResolver.class); @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception e) &#123; //写日志 logger.error("运行时异常", e); //发短信:第三方运营商的服务;发邮箱 //跳转到错误页面 ModelAndView modelAndView = new ModelAndView(); //跳转到指定的页面 modelAndView.setViewName("error/exception"); modelAndView.addObject("message", "您的网络异常,请稍后重试"); return modelAndView; &#125;&#125; Springmvc中配置异常处理器 12&lt;!-- 全局异常处理器 --&gt;&lt;bean class="com.taotao.search.exception.GlobalExceptionResolver"&gt;&lt;/bean&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SolrJ基本使用]]></title>
      <url>%2F2017%2F04%2F14%2FSolrJ%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo基本命令使用]]></title>
      <url>%2F2017%2F04%2F13%2Fhexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[创建一个笔记”markdown格式的”,然后用markdown编译器进行编辑: hexo new &quot;笔记名称&quot; 生成静态文件在项目中: hexo generate 保存到git中: npm install hexo-deployer-git --save 提交到github中: hexo deploy 内容分类标签: categories: 分类名称 标签: tags: 标签分类 查看更多 在图片下面插入&lt;!--more--&gt;标签 设置该文章禁用评论功能 comments: false markdown文件里面插入一个网页1&lt;iframe src="你要插入的网址" width="100%" height="2000px" frameborder="0" scrolling="yes"&gt; &lt;/iframe&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lucene&Solr_day02]]></title>
      <url>%2F2017%2F04%2F12%2FLucene-Solr-day02%2F</url>
      <content type="text"><![CDATA[solr与Tomcat整合 tomcat下载: solr下载: 把下载下来的包解压 进入到dist目录下找到solr-x.xx.x.war的war包 把该war包复制到tomcat目录下的webapp目录下,并改名为solr.war 方便标记 把\solr-x.xx.x\example\lib\ext目录下的所有的jar包添加到solr工程中 把\solr-x.xx.x\example\solr文件夹复制到任意盘符路径下，改名为solrhome改名是为了方便理解 在solrhome下有一个文件夹叫做collection1这就是一个solrcore的实例 一个solrcore相当于mysql中一个数据库,Solrcore之间是相互隔离. 在solrhome\collection1的目录下创建一个lib目录 在tomcat中进入刚才的项目,解压war文件再在web.xml中进行配置,让其与solrhome关联大约在配置文件中的第40行 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;E:\apache-tomcat-7.0.75-windows-x86\solr_home&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 启动tomcat,在网址中输入http://localhost:8080/solr/ 效果: 具体功能介绍 Dashboard: 仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。 Logging: Solr运行日志信息 Core Admin: Solr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。 java properties: Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息 Tread Dump: 显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息 Core selector: 选择一个SolrCore进行详细操作 Analysis: 可以测试索引分析器和搜索分析器的执行情况 Dataimport: 可以定义数据导入处理器，从关系数据库将数据导入 到Solr索引库中 Document: 通过此菜单可以创建索引、更新索引、删除索引等操作 /update表示更新索引，solr默认根据id（唯一约束）域来更新Document的内容，如果根据id值搜索不到id域则会执行添加操作，如果找到则更新。 Query: 通过/select执行搜索索引，必须指定“q”查询条件方可搜索 Schema.xml: 它是Solr数据表配置文件，它定义了加入索引的数据的数据类型的。主要包括FieldTypes、Fields和其他的一些缺省设置在solrhome\collection1\conf目录下 FieldType: 子结点包括：name,class,positionIncrementGap等一些参数 name：是这个FieldType的名称 class：是Solr提供的包solr.TextField，solr.TextField 允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）和多个过滤器（filter） positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置为100。 multiValued: 该Field如果要存储多个值时设置为true，solr允许一个Field存储多个值 uniqueKey: Solr中默认定义唯一主键key为id域 copyField复制域copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索 根据关键字只搜索text域的内容就相当于搜索title和content，将title和content复制到text中 dynamicField(动态字段) 12345/*动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义一个 dynamicField，name 为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段都被认为是符合这个定义的，例如：name_i，gender_i，school_i等。自定义Field名为：product_title_t，“product_title_t”和scheam.xml中的dynamicField规则匹配成功*/ 创建索引 搜索索引 安装中文分词器 把IKAnalyzer2012FF_u1.jar添加到solr/WEB-INF/lib目录下 复制IKAnalyzer的配置文件和自定义词典和停用词词典到solr的classes下 在schema.xml中添加一个自定义的fieldType，使用中文分析器 1234&lt;!-- IKAnalyzer 中文分词系统--&gt;&lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;&lt;/fieldType&gt; 定义field，指定field的type属性为text_ik 123&lt;!--IKAnalyzer Field配置两个索引,用中文分词器解析--&gt;&lt;field name="title_ik" type="text_ik" indexed="true" stored="true" /&gt;&lt;field name="content_ik" type="text_ik" indexed="true" stored="false" multiValued="true"/&gt; 重启tomcat测试: 设置业务系统从数据库批量导入数据 如果不使用Solr提供的Field可以针对具体的业务需要自定义一套Field，如下是商品信息Field. 12345678910&lt;!--product--&gt;&lt;field name="product_name" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="product_price" type="float" indexed="true" stored="true"/&gt;&lt;field name="product_description" type="text_ik" indexed="true" stored="false" /&gt;&lt;field name="product_picture" type="string" indexed="false" stored="true" /&gt;&lt;field name="product_catalog_name" type="string" indexed="true" stored="true" /&gt;&lt;field name="product_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/&gt;&lt;copyField source="product_name" dest="product_keywords"/&gt;&lt;copyField source="product_description" dest="product_keywords"/&gt; 把dataimport插件依赖的jar包添加到solrcore（collection1\lib）中 mysql的数据库驱动 配置solrconfig.mxl文件，添加一个requestHandler 12345&lt;requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"&gt; &lt;lst name="defaults"&gt; &lt;str name="config"&gt;data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 在collection1\conf\目录下创建一个data-config.xml文件 内容如下 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;dataConfig&gt;&lt;dataSource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost:3306/lucene" user="root" password="123"/&gt; &lt;document&gt; &lt;entity name="product" query="SELECT pid,name,catalog_name,price,description,picture FROM products "&gt; &lt;field column="pid" name="id"/&gt; &lt;field column="name" name="product_name"/&gt; &lt;field column="catalog_name" name="product_catalog_name"/&gt; &lt;field column="price" name="product_price"/&gt; &lt;field column="description" name="product_description"/&gt; &lt;field column="picture" name="product_picture"/&gt; &lt;/entity&gt; &lt;/document&gt; &lt;/dataConfig&gt; 重启tomcat并把数据导入到索引库 删除指定ID的索引 查询 删除查询到的索引数据 1234&lt;delete&gt; &lt;query&gt;product_catalog_name:幽默杂货&lt;/query&gt;&lt;/delete&gt;&lt;commit/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lucene&Solr_day01]]></title>
      <url>%2F2017%2F04%2F11%2FLucene-Solr-day01%2F</url>
      <content type="text"><![CDATA[Lucene实现全文检索的流程 数据分类 结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等 非结构化数据: 指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件 Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面索引和搜索流程图 创建文档对象 获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。 我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容） 注意:每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同） 文档分析 根据规定的规则,把文档的文件名,路径,文本内容,文本大小等信息筛选出来 123456/*将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。例如：文件名中包含apache和文件内容中包含的apache是不同的term。 */ 查询索引 查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件） 下载地址:http://lucene.apache.org/ Field域的属性 创建索引库代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Testpublic void test1() throws IOException&#123; //创建一个解析器 StandardAnalyzer analyzer = new StandardAnalyzer(); //创建一个IndexWriterConfig解析对象 //第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST,analyzer); //指定索引库存放的路径 FSDirectory directory = FSDirectory.open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\test")); //创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory,config); //初始文件的位置 File file = new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\first"); for (File f : file.listFiles()) &#123; //获取文件名 String fileName = f.getName(); //获取文件的大小 Long fileSize = FileUtils.sizeOf(f); //获取文件的内容 String fileContent = FileUtils.readFileToString(f); //获取文件的路径 String filePath = f.getPath(); //文件名域 TextField fileNameField = new TextField("name",fileName,Store.YES); //配置文件大小域 LongField fileSizeField = new LongField("size",fileSize,Store.YES); //配置文件内容域 TextField fileContentField = new TextField("content",fileContent,Store.YES); //配置文件路径域 StoredField filePathField = new StoredField("path",filePath); //创建一个Document对象 Document document = new Document(); //把文件的各个域放在Document中 document.add(fileNameField); document.add(fileSizeField); document.add(fileContentField); document.add(filePathField); //把Document添加到IndexWriter里面去 indexWriter.addDocument(document); &#125; //执行完成后要记得关闭IndexWriter indexWriter.close();&#125; 生成的数据为 查询索引库代码实现 创建一个Directory对象，也就是索引库存放的位置 创建一个indexReader对象，需要指定Directory对象 创建一个indexsearcher对象，需要指定IndexReader对象 创建一个TermQuery对象，指定查询的域和查询的关键词 执行查询 返回查询结果。遍历查询结果并输出 关闭IndexReader对象 1234567891011121314151617181920212223@Testpublic void searchIndex() throws IOException&#123; //指定索引库存放的路径 FSDirectory directory = FSDirectory.open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\jar\\luke\\test")); //创建 indexsearcher对象 DirectoryReader indexReader = DirectoryReader.open(directory); //创建IndexSearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建查询 查看有没有文件名带有的 Query query = new TermQuery(new Term("name","txt")); //执行查询 只返回两条结果 TopDocs topDocs = indexSearcher.search(query, 3); System.out.println("共查询出了"+topDocs.totalHits+"条记录"); //遍历 for (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; //scoreDoc.doc返回的就是Document的id Document document = indexSearcher.doc(scoreDoc.doc); System.out.println(document.get("name")); System.out.println(document.get("path")); System.out.println(document.get("size")); &#125; indexReader.close();&#125; 查询的结果为 中文分析器IKAnalyzer 代码 1234567891011121314151617181920212223242526272829@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); // 初始文件的位置 // 创建一个Document对象 Document document = new Document(); // 把文件的各个域放在Document中 document.add(new TextField("filename", "新添加的文档", Store.YES)); document.add(new TextField("content", "新添加的文档的内容", Store.NO)); document.add(new TextField("content", "新添加的文档的内容第二个content", Store.YES)); document.add(new TextField("content1", "新添加的文档的内容要能看到", Store.YES)); // 把Document添加到IndexWriter里面去 indexWriter.addDocument(document); // 执行完成后要记得关闭IndexWriter indexWriter.close();&#125; 删除全部代码 代码示例慎用 12345678910111213141516171819@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //删除全部索引 indexWriter.deleteAll(); //关闭indexwriter indexWriter.close();&#125; 查询条件删除 代码示例 1234567891011121314151617181920@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个查询条件 Query query = new TermQuery(new Term("filename", "apache")); //根据查询条件删除 indexWriter.deleteDocuments(query); //关闭indexwriter indexWriter.close();&#125; 索引库的修改 原理就是先删除后添加 1234567891011121314151617181920212223@Test// 中文解释器public void test() throws IOException &#123; // 创建一个解析器 IKAnalyzer analyzer = new IKAnalyzer(); // 创建一个IndexWriterConfig解析对象 // 第一个参数是lucene的版本,第二个参数是解析器的配置 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); // 指定索引库存放的路径 FSDirectory directory = FSDirectory .open(new File("F:\\就业班视频及资料\\web\\Lucene&amp;solr\\day06-08\\day06\\资料\\test2")); // 创建IndexWriter的对象,并把索引库存的路径,和配置文件写进去 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField("filename", "要更新的文档", Store.YES)); document.add(new TextField("content", "2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。", Store.YES)); indexWriter.updateDocument(new Term("content", "java"), document); //关闭indexWriter indexWriter.close();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh的Dao,Service,action]]></title>
      <url>%2F2017%2F04%2F10%2Fssh%E7%9A%84Dao-Service-action%2F</url>
      <content type="text"><![CDATA[创建实体类和映射 PowerDesigner 创建表与表之间的关系 生成pdm文件 让myeclipse链接上数据库生成实体类和对应的映射文件建立Dao,Service,action之间的关系 Dao 先创建一个BaseDao的接口里面提供一些通用的方法 1234567891011121314151617181920212223242526public interface BaseDao&lt;T&gt; &#123; public void save(T entity); public void delete(T entity); public void update(T entity); public T findById(Serializable id); public List&lt;T&gt; findAll(); /** * 根据条件查询对象查询 */ public List&lt;T&gt; findByCriteria(DetachedCriteria criteria); /** * 根据命名查询语句查询 */ public List&lt;T&gt; findByNamedQuery(String queryName,Object...args); /** * 执行增删改操作的命名语句 */ public void executeNamedQuery(String queryName,Object ...args); public Map&lt;String,Object&gt; getPage(PageBean pageBean);&#125; * 然后创建Base的实现类,实现BaseDao里面的一些抽象方法 * 首先得获得Service里面传过来的类型的对象:`如下` 1234567891011121314// 定义一个属性，表示实体的类型private Class&lt;T&gt; domainClass;/** * 在构造方法中动态获得实体的类型 */public BaseDaoImpl() &#123; // 获得父类类型 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass(); // 获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); // 获得实体类型 domainClass = (Class&lt;T&gt;) actualTypeArguments[0];&#125; * 注入会话工厂对象 12345@Resourcepublic void setSF(SessionFactory sessionFactory)&#123; //调用父类的方法注入会话工厂对象 super.setSessionFactory(sessionFactory);&#125; * 对BaseDao接口里面的方法进行实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void save(T entity) &#123; this.getHibernateTemplate().save(entity); &#125;@Overridepublic void delete(T entity) &#123; this.getHibernateTemplate().delete(entity); &#125;@Overridepublic void update(T entity) &#123; this.getHibernateTemplate().update(entity); &#125;@Overridepublic T findById(Serializable id) &#123; return this.getHibernateTemplate().get(domainClass, id);&#125;@Overridepublic List&lt;T&gt; findAll() &#123; String hql = "From "+domainClass.getSimpleName(); // TODO Auto-generated method stub return this.getHibernateTemplate().find(hql);&#125;@Overridepublic List&lt;T&gt; findByCriteria(DetachedCriteria criteria) &#123; // TODO Auto-generated method stub return this.getHibernateTemplate().findByCriteria(criteria);&#125;@Overridepublic List&lt;T&gt; findByNamedQuery(String queryName, Object... args) &#123; // TODO Auto-generated method stub return this.getHibernateTemplate().findByNamedQuery(queryName, args);&#125;@Overridepublic void executeNamedQuery(String queryName, Object... args) &#123; // TODO Auto-generated method stub Session session = (Session) this.getSession(); Query query = session.getNamedQuery(queryName); if (args != null &amp;&amp; args.length &gt; 0) &#123; int i = 0; for (Object arg : args) &#123; query.setParameter(i++, arg); &#125; &#125; query.executeUpdate();&#125;@Overridepublic Map&lt;String,Object&gt; getPage(PageBean pageBean) &#123; // TODO Auto-generated method stub pageBean.setTotal(findAll().size()); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("total", pageBean.getTotal()); int firstResult = (pageBean.getCurrentPage()-1)*pageBean.getPageSize(); int maxResults = pageBean.getPageSize(); List&lt;Object&gt; list = this.getHibernateTemplate().findByCriteria(pageBean.getDetachedCriteria(), firstResult, maxResults); map.put("rows", list);/* Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println("key:"+string+" value:"+map.get(string)); &#125;*/ return map;&#125; * `在书写实体类Dao的接口时,这个接口要继承BaseDao接口` * `在书写实体类Dao接口的实现类的时候,要继承BaseDao接口的实现类.` * 注意类上面要写 `@Repository` Service 提供service层的实现类和接口,并在实现类里面注入Dao层的实体对象接口@Resource 在实现类上面要加上注解@Service @Transactional Action 创建BaseAction 继承ActionSupport类 实现 ModelDriven接口 public class BaseAction&lt;T&gt; extends ActionSupport implements ModelDriven&lt;T&gt; { } 获得传过来的模型对象 123456789101112131415161718192021222324252627//声明模型对象protected T model;public T getModel() &#123; return model;&#125; //在构造方法中动态获得实体的类型，并通过反射实例化模型对象public BaseAction() &#123; //获得父类（BaseAction&lt;T&gt;）类型 ParameterizedType genericSuperclass = (ParameterizedType) this.getClass().getGenericSuperclass(); //获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); //实体类型 Class&lt;T&gt; domainClass = (Class&lt;T&gt;) actualTypeArguments[0]; try &#123; //创建PageBean的离线查询对象 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(domainClass); pageBean.setDetachedCriteria(detachedCriteria); //创建模型对象并赋给model model = domainClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; * 在里面填写`@Resource`标签注入XxxService * 注意权限访问范围是&apos;protected&apos; * 其余代码 123456789protected PageBean pageBean = new PageBean();public void setCurrentPage(int currentPage)&#123; pageBean.setCurrentPage(currentPage);&#125;public void setPageSize(int pageSize)&#123; pageBean.setPageSize(pageSize);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[activiti流程管理]]></title>
      <url>%2F2017%2F04%2F10%2Factiviti%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[activiti的搭建.完成自动创表 创建一个xml的配置文件 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 配置一个流程引擎对象 --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcDriver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///activiti_day01"&gt;&lt;/property&gt; &lt;property name="jdbcUsername" value="root"&gt;&lt;/property&gt; &lt;property name="jdbcPassword" value="123"&gt;&lt;/property&gt; &lt;property name="databaseSchemaUpdate" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个流程引擎工厂bean，用于创建流程引擎对象 --&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建一个测试类运行测试类,在数据库里面表就创建好了 1234567891011121314package com.yyt.activiti;import org.activiti.engine.ProcessEngineConfiguration;import org.junit.Test;public class Demo &#123; @Test public void test1() &#123; ProcessEngineConfiguration conf = ProcessEngineConfiguration .createProcessEngineConfigurationFromResource("activiti-context.xml", "processEngineConfiguration"); conf.buildProcessEngine(); &#125;&#125; 或者在xml配置文件内容不变的前提下,测试类还可以这样写 前提: 配置文件的名称必须为activiti-context.xml或者为activiti.cfg.xml,xml配置文件中必须配置流程引擎配置对象，id必须为processEngineConfiguration，必须配置流程引擎工厂bean，id必须为processEngine 1234@Testpublic void test2()&#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();&#125; 了解activiti框架提供的23张表Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 ACTRE*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 ACTRU*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 ACTID*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACTHI*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACTGE*: 通用数据， 用于不同场景下 部署流程定义 定义一个全局变量的ProcessEngine因为这个属性很常用 private ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); 部署流程定义就是将设计的流程规则保存到数据库中 代码 12345678910111213141516171819@Testpublic void test3()&#123; //配置流程的规则把myActiviti.bpmn导入进去 //配置流程的图解,导入myActiviti.png /* 先获取流程定义和流程静态资源 （图片，规则，等等）对象,然后再在关于流程规则和定义中的表中,创建deployment表的对象,这与数据库中的deployment表对应 */ DeploymentBuilder deploymentBuilder = processEngine.getRepositoryService().createDeployment(); //在数据库中插入图片 deploymentBuilder.addClasspathResource("myActiviti.png"); //在数据库中插入规则 deploymentBuilder.addClasspathResource("myActiviti.bpmn"); //提交数据,把数据提交到数据库中 Deployment deployment = deploymentBuilder.deploy(); //打印deployment表中的id值 System.out.println(deployment.getId()); &#125; 查询流程定义 代码实现 12345678910111213141516// 查询流程的定义@Testpublic void test4() &#123; // 获得流程查询对象 ProcessDefinitionQuery query = processEngine.getRepositoryService().createProcessDefinitionQuery(); //根据数据库中的key过滤 query.processDefinitionKey("myProcess"); //根据Version 版本 进行降序排序 query.orderByProcessDefinitionVersion().desc(); //把query转成list集合,泛型为ProcessDefinition List&lt;ProcessDefinition&gt; list = query.list(); for (ProcessDefinition processDefinition : list) &#123; System.out.println(processDefinition.getVersion()); &#125;&#125; 流程实例根据某个流程定义(流程的规则)的一次具体执行过程，就是一个流程实例(按照流程规则执行的一次事件)。流程定义和流程实例是一对多的关系 启动一个流程实例 12345678910@Testpublic void test5()&#123; //写出在数据库名为procdef的表中的id String procdefId = "myProcess:1:4"; //获得运行时的Service,并开始处理流程实例,根据procdef表中的id //一般根据KEY生成一个实例,根据KEY生成的话,默认是按照最新版本的流程规则创造流程实例 ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceById(procdefId); //打印出流程实例对象的id 对应数据表中的execution中表的id ps:execution表中ACT_ID_ 表示的是该任务节点的处理人 System.out.println(processInstance.getId());&#125; 在act_ru_task表里会保存当前任务的信息，包括流程实例的IdPROC_INST_ID_，任务名称NAME_，任务的办理人ASSIGNEE_ 查询任务1234567891011@Testpublic void test6()&#123; //通过获取task的service,来创建task的查询对象 ps task:正在执行任务的表 TaskQuery query = processEngine.getTaskService().createTaskQuery(); //向查询对象中添加过滤条件(通过Assignee:本次任务第一阶段的处理人),并转换为list集合 List&lt;Task&gt; list = query.taskAssignee("张三").list(); for (Task task : list) &#123; //打印task表中满足过滤条件的name信息 System.out.println(task.getName()); &#125;&#125; 办理任务把任务推往下一层12345@Testpublic void test7()&#123; //里面填写task表中的ID,就把当前任务id的流程推向了下一层去审批 processEngine.getTaskService().complete("504");&#125; 流程变量 就比如你请假,向领导报告请假理由和请假天数,而这些参数就是流程变量,这些变量在整个流程中都是可以被随时调用的 流程变量保存在act_ru_variable表中 Name字段保存的是变量的key,Text字段保存的是变量的value 代码一:在创建实例的时候向方法里面添加参数(有参构造) 12345678@Testpublic void test8()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "割包皮"); map.put("请假天数","15"); //ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceByKey("myProcess", map); ProcessInstance processInstance = processEngine.getRuntimeService().startProcessInstanceById("myProcess:2:104", map);&#125; 代码二:办理任务时设置 1234567@Testpublic void test9()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "世界这麽大我想去看看"); map.put("请假天数","无限期"); processEngine.getTaskService().complete("404",map);&#125; ps:在流程变量设置好后,向下一级提交的时候,该流程变量也可以改变 就比如你向项目经理请假,想请2天假原因是XXX过生日,但是项目经理向部门经理反映的是你想请20天的假原因是世界这麽大我想去看看 代码: 12345678@Testpublic void test10()&#123; //里面填写task表中的ID,就把当前任务id的流程推向了下一层去审批 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "他不想干了"); map.put("请假天数","干脆把他开除了吧!"); processEngine.getTaskService().complete("1304",map);&#125; 代码三:在RuntimeService方法里面设置 12345678@Testpublic void test11()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "不想上班了"); map.put("请假天数","辞职"); //设置多个流程变量用这个,设置单个的话用setVariables("流程id",流程变量标题,流程变量的内容) processEngine.getRuntimeService().setVariables("1001", map);&#125; 代码四:TaskService的方法设置流程变量 1234567@Testpublic void test12() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("请假原因", "不吻"); map.put("请假天数", "滚"); processEngine.getTaskService().setVariables("1106", map);&#125; 获取流程变量 代码一根据RuntimeService方法获取 12345678910@Testpublic void test13() &#123; Map&lt;String, Object&gt; map = processEngine.getRuntimeService().getVariables("1101"); Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println(string + "--" + map.get(string)); &#125;&#125; 代码二根据TaskService方法获取 123456789@Testpublic void test14() &#123; Map&lt;String, Object&gt; map = processEngine.getTaskService().getVariables("1106"); Set&lt;String&gt; set = map.keySet(); for (String string : set) &#123; System.out.println(string + "--" + map.get(string)); &#125;&#125; 候选组 组任务 先启动一个流程实例 创建一个组 12345678//创建财务人员组@Testpublic void test3()&#123; Group group = new GroupEntity(); group.setId("财务人员组"); group.setName("财务人员组猪猪"); processEngine.getIdentityService().saveGroup(group);&#125; 再创建一个用户 123456789//创建一个用户@Testpublic void test4()&#123; Group group = new GroupEntity(); User user = new UserEntity(); user.setId("002"); user.setFirstName("小黄"); processEngine.getIdentityService().saveUser(user);&#125; 将用户加入组中 1234567//将用户加入组中@Testpublic void test5()&#123; String userid = "002"; String group = "主管人员组"; processEngine.getIdentityService().createMembership(userid, group);&#125; 然后在流程处理到了组哪里的时候,就把组里面的单个人提取出来,为你办理任务123456@Testpublic void test8()&#123; String taskid = "2805"; String userid = "002"; processEngine.getTaskService().claim(taskid, userid);&#125; 排他网关 结构图 ${qjtj&lt;50} |------&gt;{部门经理}----- | | | | 开始---&gt;{自己}----&gt; X------&gt;{项目经理}-----|-----&gt;{老板}---&gt;结束 | | | | |------&gt;{区域经理}----- ${qjtj&lt;250} 在导入流程规则和图片,并开始处理流程实例后执行下面的代码 执行流程 123456789//执行流程@Testpublic void test3()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String, Object&gt;(); //map集合里面,第一个是条件的名称,给该条件的值 map.put("qjtj", 25); //把条件与流程的id一并提交 processEngine.getTaskService().complete("3204", map);&#125; 查询执行上一个带条件的流程后,现在改流程的name字段,结果应该为 “部门经理” 123456789@Testpublic void test4()&#123; TaskQuery query = processEngine.getTaskService().createTaskQuery(); query.taskId("3304"); List&lt;Task&gt; list = query.list(); for (Task task : list) &#123; System.out.println(task.getName()); &#125;&#125; 并行网关当工作流程运行到并行网关时，会同时开启多条运行的流程实例，多条流程实例可以同时进行，而且，只有所有并行网关的分支流程实例全部执行完毕，流程汇聚，当前任务完成。 分支（fork）:通过了并行网关后，流程实例被分成了若干个子流程 汇聚（join）:子流程执行完毕，最后会集中到主流程上，只要有任意一个子流程没有执行完毕，那么就不会汇聚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro权限管理]]></title>
      <url>%2F2017%2F04%2F10%2FShiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[shiro的配置过程 在web.xml中配置一个过滤器代理对象 123456789&lt;!-- 加入spring框架提供的过滤器代理对象 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在spring配置文件中配置一个名称为shiroFilter的bean,并注入安全管理器 123456789101112131415161718192021222324252627282930313233&lt;!-- 配置安全管理器 --&gt;&lt;bean name="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="bosRealm"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="bosRealm" class="com.yyt.bos.shiro.BOSRealm"&gt;&lt;/bean&gt;&lt;!-- 配置shiro的bean --&gt;&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- 注入安全管理器对象 --&gt; &lt;property name="securityManager" ref="securityManager"&gt;&lt;/property&gt; &lt;!-- 成功的界面 --&gt; &lt;property name="successUrl" value="/index.jsp"&gt;&lt;/property&gt; &lt;!-- 权限不足提示页面 --&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"&gt;&lt;/property&gt; &lt;!-- 登录页面的Url --&gt; &lt;property name="loginUrl" value="/login.jsp"&gt;&lt;/property&gt; &lt;!-- 基于url拦截,使用过滤器进行拦截 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;!-- anon:权限拦截白名单 --&gt; &lt;value&gt; /css/** = anon /images/** = anon /js/** = anon /login.jsp = anon /validatecode.jsp* = anon /userAction_login.action = anon /page_base_staff.action = perms["staff"] /** = authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; bean的名字为bosRealm所在类的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.yyt.bos.shiro;import java.util.List;import javax.annotation.Resource;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import com.yyt.bos.dao.FunctionDao;import com.yyt.bos.dao.UserDao;import com.yyt.bos.entity.Function;import com.yyt.bos.entity.User;public class BOSRealm extends AuthorizingRealm &#123; @Resource private UserDao userDao; @Resource private FunctionDao functionDao; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection paramPrincipalCollection) &#123; // TODO Auto-generated method stub SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); /*info.addStringPermission("staff"); info.addStringPermission("staff-delete");*/ User user = (User) paramPrincipalCollection.getPrimaryPrincipal(); if("李四".equals(user.getUsername()))&#123; List&lt;Function&gt; list = functionDao.findAll(); info.addStringPermission("staff-delete"); info.addStringPermission("staff-add"); for (Function function : list) &#123; System.out.println(function.getName()); info.addStringPermission(function.getCode()); &#125; &#125;else&#123; String id = user.getId(); List&lt;Function&gt; list = functionDao.findFunctionByUsername(id); for (Function function : list) &#123; System.out.println(function.getName()); info.addStringPermission(function.getCode()); &#125; &#125; return info; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; UsernamePasswordToken mytoken = (UsernamePasswordToken) token; String username = mytoken.getUsername(); char[] password = mytoken.getPassword(); User user = userDao.findUserByUsername(username); if(user == null)&#123; return null; &#125; //如果从数据库里面返回的user部位null的话,就说明签名通过了. //三个参数分别为:签名对象;从数据库中查到的密码;reaml的类名 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this.getClass().getName()); return info; &#125;&#125; 修改用户Action里面的登录方法 1234567891011121314151617181920212223public String login()&#123; Subject subject = SecurityUtils.getSubject(); String username = model.getUsername(); String password = model.getPassword(); password = MD5Utils.md5(password); try&#123; AuthenticationToken token = new UsernamePasswordToken(username,password); subject.login(token); User user = (User) subject.getPrincipal(); ServletActionContext.getRequest().getSession().setAttribute("user", user); &#125;catch (UnknownAccountException e) &#123; e.printStackTrace(); this.addActionError("用户名不存在"); return "login"; // TODO: handle exception &#125;catch (IncorrectCredentialsException e)&#123; e.printStackTrace(); this.addActionError("密码错误"); return "login"; &#125; return "home";&#125; 注解方式权限控制 在spring的配置文件中写自动代理和切面 1234567&lt;!-- 自动代理 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt; &lt;property name="proxyTargetClass" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 切面 --&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt;&lt;/bean&gt; 在Action作废的方法上面写注解 12@RequiresPermissions("staff-delete")public String deleteStaff()&#123;...&#125; 修改BaseAction的构造方法虚线中间的为要修改的内容 1234567891011121314151617181920212223242526272829303132//在构造方法中动态获得实体的类型，并通过反射实例化模型对象public BaseAction() &#123;--------------------------------------------------------------------------------------------------- // 获得父类（BaseAction&lt;T&gt;）类型 ParameterizedType genericSuperclass = null; Type genericSuperclass2 = this.getClass().getGenericSuperclass(); if(genericSuperclass2 instanceof ParameterizedType)&#123; genericSuperclass = (ParameterizedType) genericSuperclass2; &#125;else&#123; genericSuperclass = (ParameterizedType) this.getClass().getSuperclass().getGenericSuperclass(); &#125;--------------------------------------------------------------------------------------------------- //获得父类上的泛型数组 Type[] actualTypeArguments = genericSuperclass.getActualTypeArguments(); //实体类型 Class&lt;T&gt; domainClass = (Class&lt;T&gt;) actualTypeArguments[0]; try &#123; //创建PageBean的离线查询对象 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(domainClass); pageBean.setDetachedCriteria(detachedCriteria); //创建模型对象并赋给model model = domainClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 在jsp页面上根据不同登录用户隐藏按钮 123456789/* 如果登录的用户有此权限则按钮不隐藏,没有此权限则 隐藏按钮*/&lt;shiro:hasPermission name="staff-add"&gt;, &#123; id : 'button-add', text : '增加', iconCls : 'icon-add', handler : doAdd&#125;&lt;/shiro:hasPermission&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssm三大框架整合]]></title>
      <url>%2F2017%2F04%2F10%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[easyui初级使用]]></title>
      <url>%2F2017%2F04%2F10%2Feasyui%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[什么是easyui jquery easyui不需要写复杂的css和html代码，就可以实现一些页面效果 使用jquery easyui和后台进行交互 通过后台（action）返回json数据到页面 底层使用jquery ajax+json数据 应用场景 使用jquery easyui一般用在后台管理系统基本案例DataGrid(数据表格) DataGrid属性1234567891011121314151617&lt;table class="easyui-datagrid"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th data-options="field:'code'"&gt;编码&lt;/th&gt; &lt;th data-options="field:'name'"&gt;名称&lt;/th&gt; &lt;th data-options="field:'price'"&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;001&lt;/td&gt;&lt;td&gt;名称1&lt;/td&gt;&lt;td&gt;2323&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;002&lt;/td&gt;&lt;td&gt;名称2&lt;/td&gt;&lt;td&gt;4612&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; class=”easyui-datagrid”表示引入easy的表格样式 field :列字段的名称 pagination :是否显示分页条工具 rownumbers :是否显示数据表格的行号 pagePosition :定义分页工具栏的位置,可选值有’top’,’bottom’,’both’ loader 定义如何从远程服务器加载数据。返回false可以放弃本次请求动作。该函数接受以下参数： param：参数对象传递给远程服务器。 success(data)：当检索数据成功的时候会调用该回调函数 error()：当检索数据失败的时候会调用该回调函数 loadFilter 返回过滤数据显示。该函数带一个参数’data’用来指向源数据（即：获取的数据源，比如Json对象）。您可以改变源数据的标准数据格式。这个函数必须返回包含’total’和’rows’属性的标准数据对象。 代码示例 12345678910// 从Web Service（asp.net、java、php等）输出的JSON对象中移除'd'对象$('#dg').datagrid(&#123; loadFilter: function(data)&#123; if (data.d)&#123; return data.d; &#125; else &#123; return data; &#125; &#125;&#125;); 列属性12345678910columns:[[ &#123;field:'itemid',title:'Item ID',rowspan:2,width:80,sortable:true&#125;, &#123;field:'productid',title:'Product ID',rowspan:2,width:80,sortable:true&#125;, &#123;title:'Item Details',colspan:4&#125; ],[ &#123;field:'listprice',title:'List Price',width:80,align:'right',sortable:true&#125;, &#123;field:'unitcost',title:'Unit Cost',width:80,align:'right',sortable:true&#125;, &#123;field:'attr1',title:'Attribute',width:100&#125;, &#123;field:'status',title:'Status',width:60&#125; ]] title :列标题文本 field :列字段名 width :列的宽度,如果没有设置则表示自适应 rowspan :合并行 colspan :合并列 resizable :允许列改变大小 hidden :如果为true,表示隐藏 checkbox :如果为true则显示复选框对话窗口 12345678&lt;div class="easyui-dialog" style="width:600px;height:300px" data-options="title:'我的对话框',toolbar:'#tb',modal:true"&gt; 对话框窗口内容。里面可以插入一个表格&lt;/div&gt;&lt;div id="tb"&gt; &lt;a href="#" class="easyui-linkbutton" data-options="iconCls:'icon-edit',plain:true"/a&gt; &lt;a href="#" class="easyui-linkbutton" data-options="iconCls:'icon-help',plain:true"/a&gt;&lt;/div&gt; layout布局tab选项卡 1234567891011&lt;div id="tt" class="easyui-tabs" style="width:500px;height:250px;"&gt; &lt;div title="Tab1" style="padding:20px;display:none;"&gt; tab1 &lt;/div&gt; &lt;div title="Tab2" data-options="closable:true" style="overflow:auto;padding:20px;display:none;"&gt; tab2 &lt;/div&gt; &lt;div title="Tab3" data-options="iconCls:'icon-reload',closable:true" style="padding:20px;display:none;"&gt; tab3 &lt;/div&gt;&lt;/div&gt; tools 工具栏添加在选项卡面板头的左侧或右侧 1234567$('#tt').tabs(&#123; tools:'#tab-tools'&#125;);&lt;div id="tab-tools"&gt; &lt;a href="#" class="easyui-linkbutton" plain="true" iconCls="icon-add"&gt;&lt;/a&gt; &lt;a href="#" class="easyui-linkbutton" plain="true" iconCls="icon-save"&gt;&lt;/a&gt;&lt;/div&gt; onSelect 在选中一个选项卡时触发 onAdd 在添加一个选项卡时触发Accordion分类 12345678910111213&lt;div id="aa" class="easyui-accordion" style="width:300px;height:200px;"&gt; &lt;div title="Title1" data-options="iconCls:'icon-save'" style="overflow:auto;padding:10px;"&gt; &lt;h3 style="color:#0099FF;"&gt;Accordion for jQuery&lt;/h3&gt; &lt;p&gt;Accordion is a part of easyui framework for jQuery. It lets you define your accordion component on web page more easily.&lt;/p&gt; &lt;/div&gt; &lt;div title="Title2" data-options="iconCls:'icon-reload',selected:true" style="padding:10px;"&gt; content2 &lt;/div&gt; &lt;div title="Title3"&gt; content3 &lt;/div&gt; &lt;/div&gt; layout布局 完整页面布局 1234567&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'north',title:'North Title',split:true" style="height:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'south',title:'South Title',split:true" style="height:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'east',iconCls:'icon-reload',title:'East',split:true" style="width:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'west',title:'West',split:true" style="width:100px;"&gt;&lt;/div&gt; &lt;div data-options="region:'center',title:'center title'" style="padding:5px;background:#eee;"&gt;&lt;/div&gt; &lt;/body&gt; 嵌套布局 123456789&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'north'" style="height:100px"&gt;&lt;/div&gt; &lt;div data-options="region:'center'"&gt; &lt;div class="easyui-layout" data-options="fit:true"&gt; &lt;div data-options="region:'west',collapsed:true" style="width:180px"&gt;&lt;/div&gt; &lt;div data-options="region:'center'"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 布局面板加载外部数据&lt;body class="easyui-layout"&gt; &lt;div data-options="region:'west',href:'west_content.php'" style="width:180px" &gt;&lt;/div&gt; &lt;div data-options="region:'center',href:'center_content.php'" &gt;&lt;/div&gt; &lt;/body&gt; 把布局面板区域添加指定面板 具体操作看面板 $('#cc').layout('add',{ region: 'west', width: 180, title: 'West Title', split: true, tools: [{ iconCls:'icon-add', handler:function(){alert('add')} },{ iconCls:'icon-remove', handler:function(){alert('remove')} }] }); 先写这么多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis_day02]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis-day02%2F</url>
      <content type="text"><![CDATA[定义resultMap如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。 resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 resultMap的配置 1234567&lt;resultMap type="com.yyt.mybatis.po.User" id="userListResultMap"&gt; &lt;id column="_id" property="id"/&gt; &lt;result column="_name" property="username"/&gt; &lt;result column="_birthday" property="birthday"/&gt; &lt;result column="_sex" property="sex"/&gt; &lt;result column="_address" property="address"/&gt;&lt;/resultMap&gt; 123&lt;select id="findUserListForResultMap" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT id _id,username _name,birthday _birthday,sex _sex,address _address FROM `user`&lt;/select&gt; 动态sql if语句 1234567891011&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user where 1=1 &lt;if test="id!=null"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; where语句 1234567891011&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach语句 向sql传递数组或List，mybatis使用foreach解析 mapper配置queryvo类中包括一个Integer集合ids 12345678910&lt;select id="findUserByForeach" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT * FROM USER WHERE username LIKE '%张%' &lt;!-- 判断queryvo对象里面的ids集合--&gt; &lt;if test="ids !=null and ids.size&gt;0"&gt; &lt;!-- 遍历ids,并非在上面sql语句上加入 and id in(......) 括号中间写遍历的参数以逗号隔开--&gt; &lt;foreach collection="ids" open="and id in(" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt; * 运行结果 * `Preparing: SELECT * FROM USER WHERE username LIKE &apos;%张%&apos; and id in( ? , ? , ? )` * `Parameters: 10(Integer), 89(Integer), 16(Integer)` sql片段 Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的 代码如下 1234567891011121314&lt;select id="findUserListForResultMap" parameterType="queryvo" resultMap="userListResultMap"&gt; SELECT id _id,username _name,birthday _birthday,sex _sex,address _address FROM `user` &lt;where&gt; &lt;include refid="id_username_user"/&gt; &lt;/where&gt;&lt;/select&gt;&lt;sql id="id_username_user"&gt; &lt;if test="user.id != null and user.id != ''"&gt; and id=$&#123;user.id&#125; &lt;/if&gt; &lt;if test="user.username != null and user.username != ''"&gt; and username like '%$&#123;user.username&#125;%' &lt;/if&gt;&lt;/sql&gt; 关联查询 一对一的查询一张订单对应只有一个用户 mapper代码 1234567891011121314151617181920212223242526272829303132&lt;!-- 查询订单关联用户信息使用resultmap --&gt;&lt;resultMap type="Orders" id="orderUserResultMap"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 一对一关联映射 --&gt; &lt;!-- property:Orders对象的user属性 javaType：user属性对应 的类型 --&gt; &lt;association property="user" javaType="cn.itcast.po.User"&gt; &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="findOrdersWithUserResultMap" resultMap="orderUserResultMap"&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM orders o JOIN `user` u ON u.id = o.user_id&lt;/select&gt; * 在订单实体类中加入用户的属性,并提供get,set方法 一对多查询一个用户可以有多个订单 mapper代码 1234567891011121314151617181920212223242526&lt;!-- 配置一对多的关系 --&gt;&lt;resultMap type="user" id="userAndordersMapper"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="birthday" column="birthday"/&gt; &lt;result property="sex" column="sex"/&gt; &lt;result property="address" column="address"/&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property="orders" ofType="orders"&gt; &lt;id property="id" column="oid"/&gt; &lt;result property="number" column="number"/&gt; &lt;result property="createtime" column="createtime"/&gt; &lt;result property="note" column="note"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 一对多的sql语句的写法配置 --&gt;&lt;select id="findUserOrdersByUser" resultMap="userAndordersMapper"&gt; SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id&lt;/select&gt; * 在用户实体类中加入订单对象的list集合属性,并提供get和set方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis_day01]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis-day01%2F</url>
      <content type="text"><![CDATA[Mybatis基本的配置 首先创建一个实体类并提供get,set和toString方法 12345678public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; ........&#125; 加载log4j配置文件内容如下 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 在同级目录下创建接口和mapper配置文件两个文件的名称要相同 接口里面填写的是各种增删改查的方法 12345public interface UserMapper &#123; public User findUserByid(int id); public void insertUser(User user); public List&lt;User&gt; findAllUser();&#125; mapper配置文件的代码 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 这里因为接口和mapper文件都在同级目录,所以要填写本文件的包全路径 --&gt;&lt;mapper namespace="com.yyt.mybatis.mapper.UserMapper"&gt; &lt;!-- id:方法名,parameterType:传入方法里面的参数,resultType:方法执行后返回的参数类型 --&gt; &lt;select id="findUserByid" parameterType="int" resultType="com.yyt.mybatis.po.User"&gt; select * from `user` where id=#&#123;id&#125;; &lt;/select&gt; &lt;select id="insertUser" parameterType="com.yyt.mybatis.po.User"&gt; INSERT INTO USER(username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/select&gt; &lt;select id="findAllUser" resultType="com.yyt.mybatis.po.User"&gt; select * from `user`; &lt;/select&gt;&lt;/mapper&gt; mybatis核心配置文件的配置 SqlMapConfig.xml文件代码 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 链接数据库 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper class="com.yyt.mybatis.mapper.UserMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建一个测试类测试一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory = null; @Before public void init() throws Exception &#123; //第一步：创建一个SQLSessionFactoryBuilder对象。 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //第二步：加载配置文件。 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); //第三步：创建SQLSessionFactory对象 sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testFindUserByid() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); User user = userMapper.findUserByid(1); sqlsession.close(); System.out.println(user); &#125; @Test public void testInsertUser() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); User user = new User(); user.setUsername("尼古拉斯赵四"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("湖北省武汉市江夏区汤逊湖北路8号长城科技园5栋1405"); userMapper.insertUser(user); sqlsession.commit(); sqlsession.close(); &#125; @Test public void testFindAllUser() &#123; SqlSession sqlsession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlsession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findAllUser(); sqlsession.close(); for (User user : list) &#123; System.out.println(user); &#125; &#125;&#125; #{}和${}的区别 1234/*#&#123;&#125;表示一个占位符号，通过#&#123;&#125;可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#&#123;&#125;可以有效防止sql注入。 #&#123;&#125;可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#&#123;&#125;括号中可以是value或其它名称。“%”#&#123;name&#125;”%”$&#123;&#125;表示拼接sql串，通过$&#123;&#125;可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， $&#123;&#125;可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，$&#123;&#125;括号中只能是value。*/ parameterType 指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中 resultType 指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象 selectOne 查询一条记录，如果使用selectOne查询多条记录则抛出异常 1234org.apache.ibatis.exceptions.TooManyResultsException:Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)-------------------------------没有找到selectOne方法的返回值,但发现了3个对象----------------------------- selectList 可以查询一条或多条记录。 SqlMapConfig配置文件里加载mapper映射文件有一下几种方法 &lt;mapper resource=&quot; &quot; /&gt; 使用相对于类路径的资源如： &lt;mapper class=&quot; &quot; /&gt; &lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt; 接口类路径 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 &lt;package name=&quot;&quot;/&gt; 注册指定包下的所有mapper接口 &lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 给mybatis配置别名 在SqlMapConfig.xml文件中配置 1234&lt;typeAliases&gt; &lt;!--配置别名, 填写实体类的路径 --&gt; &lt;package name="com.yyt.mybatis.po"/&gt;&lt;/typeAliases&gt; * 表示在该包路径中的实体类的别名就是他们的名字,不区分大小写. * 这样以后在mapper文件中的参数或者返回值类型就不用填写类的全路名了,直接填写别名就行了 mybatis支持的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis与spring的整合]]></title>
      <url>%2F2017%2F04%2F09%2Fmybatis%E4%B8%8Espring%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
      <content type="text"><![CDATA[SqlMapConfig.xml文件的配置 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 配置别名 --&gt; &lt;package name="com.yyt.mybayis.po"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapper class="com.yyt.mybayis.mapper.UserMapper"/&gt; &lt;mapper class="com.yyt.mybayis.mapper.OrdersMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; applicationContext.xml文件的配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载数据库参数配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 加载数据库信息 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 加载maybatis的核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:sqlmapConfig.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 分别配置两个mapper代理 --&gt; &lt;bean id="userMapperFactoryBean" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.yyt.mybayis.mapper.UserMapper"/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="ordersMapperFactoryBean" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.yyt.mybayis.mapper.OrdersMapper"/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; db.properties文件配置 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=123 测试方法 12345678910111213141516171819public class UserMapperTest &#123; private ApplicationContext applicationContext; @Before public void init() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void testFindAllUser() &#123; UserMapper userMapper = applicationContext.getBean(UserMapper.class); List&lt;User&gt; list = userMapper.findAllUser(); for (User user : list) &#123; System.out.println(user); &#125; &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
